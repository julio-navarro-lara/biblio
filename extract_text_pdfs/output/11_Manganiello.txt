Multistep Attack Detection and Alert Correlation in Intrusion Detection Systems
Fabio Manganiello, Mirco Marchetti, and Michele Colajanni
Universit` a degli Studi di Modena e Reggio Emilia, Department of Information Engineering Via Vignolese 905, Modena, Italy {fabio.manganiello, mirco.marchetti, michele.colajanni}@unimore.it

Abstract. A growing trend in the cybersecurity landscape is represented by multistep attacks that involve multiple correlated intrusion activities to reach the intended target. The duty of correlating security alerts and reconstructing complete attack scenarios is left to system administrators because current Network Intrusion Detection Systems (NIDS) are still oriented to generate alerts related to single attacks, with no or minimal correlation analysis among different security alerts. We propose a novel approach for the automatic analysis of multiple security alerts generated by state-of-the-art signature-based NIDS. Our proposal is able to group security alerts that are likely to belong to the same attack scenario, and to identify correlations and causal relationships among them. This goal is achieved by combining alert classification through Self Organizing Maps and unsupervised clustering algorithms. The efficacy of the proposal is demonstrated through a prototype tested against network traffic traces containing multistep attacks.

Keywords: Network security, machine learning, neural networks, alert clustering, alert correlation, Self-Organizing Maps

1

Introduction

The presence of a Network Intrusion Detection System (NIDS ) is a cornerstone in any modern security architecture. A typical NIDS analyzes network traffic and generates security alerts as soon as a malicious network packet is detected. Alert analysis is then performed manually by security experts that parse the NIDS logs to identify relevant alerts and verify possible causal relationships among them. While the log analysis can be simplified through some NIDS management interface, it is still a manual, time consuming and error prone process especially because we are experiencing a growing number of multistep attacks that involve multiple correlated intrusion activities. This paper proposes a novel alert correlation and clustering approach that helps security analysts in identifying multistep attacks by clustering similar alerts produced by a signature-based NIDS, such as Snort [11], and by highlighting

2

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

strong correlations and causal relationships among different clusters. This goal is achieved through multiple steps: the security alerts are preprocessed by a hierarchical clustering scheme; then, they are processed using a Self-Organizing Map ( SOM ) that is a type of auto associative neural network [6]; the alerts that likely belong to the same attack scenarios are clustered by using the k-means algorithm over the SOM output layer; finally, a correlation index is computed among the alert clusters in order to identify causal relationships that are typical of a multistep attack scenario. The final output of our framework for multistep attack detection is a set of oriented graphs. Each graph describes an attack scenario in which the vertices represent clusters belonging to the same attack scenarios, and the directed links denote alert clusters that are tied by causal relationships. In such a way, a security administrator can immediately identify correlated alerts by looking at the graphs, thus avoiding to waste time on checking false positives and irrelevant alerts. This paper presents several contributions with respect to the state of the art. The application of the k-means clustering algorithm to the output layer of a SOM allows us to perform robust and unsupervised clustering of correlated NIDS alerts. To the best of our knowledge, this solution has never been proposed in network security. Moreover, several original (for the security literature) heuristics for the SOM initialization and definition of the minimum size of the clusters produced by the k-means algorithm reduce the number of configuration parameters and allow our solution to autonomously adapt to different workloads. This is an important result because the typicial context is characterized by high variability and heterogeneity of security alerts. We demonstrate the feasibility and efficacy of the proposed solution through a prototype that was extensively tested using the most recent datasets released after the 2010 Capture the Flag competition [4]. This paper is organized as follows. Section 2 discusses related work in network security literature and outlines main improvements of this proposal with respect to the state of the art. Section 3 presents the software architecture of the proposed solution. Sections 4, 5 and 6 describe the SOM, the clustering algorithm applied to the SOM output, and the algorithm that evaluates correlations among alert clusters, respectively. Section 7 presents the experimental results. Section 8 draws the conclusions and outlines future work.

2

Related work

The application of machine learning techniques, such as neural networks and clustering algorithms, for intrusion detection has been widely explored in the security literature. Several papers propose clustering algorithms, support vector machines [7] and neural networks as the main detection engine for the implementation of anomaly-based network intrusion detection systems. In particular, the use of Self-Organizing Maps (SOM) for the implementation of an anomaly-based IDS was proposed in [14], [9] and [2]. Unlike previous literature mainly oriented to anomaly-based detection, in this paper we propose SOM and clustering algo-

Multistep Attack Detection and Alert Correlation

3

rithms for the postprocessing of security alerts generated by a signature-based NIDS. Hence, our proposal relates to other papers focusing on techniques for NIDS alert correlation [3]. According to the comprehensive framework for NIDS alert correlation proposed in [13], the solution proposed in this paper can be classified as a multistep correlation component. In this context, two related papers are [8] and [5]. In [8] authors describe an alert correlation algorithm that uses a SOM in order to compute the correlation between security alerts produced by a NIDS. Alerts are modeled as numerical tuples, and their correlation is inversely proportional to the distance distance between the two corresponding neurons on the output layer of a SOM. Correlation computed according to [8] measures the similarity between two given security alerts, and is commutative by definition. Our work differentiates from [8] because our evaluation is not limited to compute alert similarity. Indeed, mapping security alerts on the output layer of the SOM is only one intermediate steps of our framework, that takes the SOM output as the input of the alert clustering algorithms. Moreover, with respect to [8] we propose an innovative initialization algorithm for the SOM and an adaptive training strategy that makes the SOM more robust with respect to perturbations in the training data (see Section 4 for details on the design and implementation of the SOM). Finally, instead of relying just on a commutative correlation index based on the distance between two alerts, our correlation index depends also on the type of alerts and on their detection time (see Section 6). The resulting correlation index expresses the causality relationships among alerts much better than the previous one. In [5] security alerts generated by a NIDS are grouped through a hierarchical clustering algorithm. The classification hierarchy, that is defined by the user, aggregates alerts of the same type targeting one host or a set of hosts connected to the same subnet. We use a similar hierarchical clustering scheme as a preprocessing step. We then use the alert clusters generated by this hierarchical clustering algorithm as an input for the SOM. Hence, we take advantage of the ability of the algorithm presented in [5] to reduce the number of alerts to be processed, and to group a high number of false positives. All the subsequent processing steps are novel. In such a way, the proposed alert correlation algorithm could work even without the preprocessing step of a hierarchical clustering although at the price of a higher computational cost.

3

Software architecture

The architecture of the framework proposed in this paper consists of a preprocessing phase and of three main processing steps. The preprocessing phase, called hierarchical clustering in Figure 1, takes as its input the intrusion alerts generated by a signature-based NIDS. In our reference implementation, we refer to the well known Snort. Alerts are grouped according to a clustering hierarchy in a way similar to [5]. This preprocessing phase has two positive effects. It reduces the number of elements that have to be processed

4

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

by the subsequent steps, with an important reduction of the computational cost of the three processing phases. Moreover, it groups many false positives in the same cluster, thus simplifying human inspection of the security alerts. In our approach, clustered alerts are modelled as numerical normalized tuples, where each element identifies a property of a given cluster (timestamp, alert type, source and destination address and ports).

Input: NIDS alerts First processing step:SOM Second processing step: k-means clustering

Preprocessing: hierarchical clustering

Third processing step: correlation index

Output: set of correlation graphs

Fig. 1. Main functional steps of the software architecture

Clustered alerts are then processed by the Self Organizing Map (SOM) in Figure 1. The SOM is able to reduce the dimensionality of the input dataset by mapping each multidimensional tuple to one output neuron. Each output neuron is identified by its coordinates on the output layer of the SOM, hence the multi-dimensional tuples that represent clustered alerts are mapped to twodimensional coordinate sets on the output layer. Moreover, a SOM has the ability to map similar tuples to neurons that are close in the output layer. The use of

Multistep Attack Detection and Alert Correlation

5

SOM allows us to reduce the dimensionality of the dataset while preserving information related to input similarity. In particular, the distance between two output neurons on the output layer of the SOM is inversely proportional to the similarity of the related inputs. The output of the SOM is then analyzed by the second processing step, that is a k -means clustering algorithm aiming to detect similar alert clusters that are likely to belong to the same attack scenario. The basic idea is that similar alert clusters are mapped on close neurons of the SOM, hence it is possible to group similar alert clusters by executing a k -means clustering on the output layer of the SOM, as shown in Figure 1. The choice of the parameter k is critical. Our proposal includes a heuristic that computes the best k on the basis of the data analyzed so far, as illustrated in Section 5. This approach allows our clustering algorithm to automatically adapt its parameters without the need of a static value for k that risks to be unsuitable in most instances. The output of the proposed k -means clustering algorithm, described in Section 5, is a set of clusters each representing a likely attack scenario. The third (and last) processing step evaluates correlations between alert clusters belonging to the same attack scenario. It takes as its input the output layer of the SOM and the results of the k -means clustering algorithm, and then computes a correlation index between alert clusters that have been grouped within the same cluster by the k -means algorithm. The computation of the correlation index is based on the distance between the neurons on the output layer of the SOM, on the timing relationships between alerts and on their type. In particular, this algorithm identifies causal relationships between alerts by determining which of the two alerts occurred first, and whether historical data show that alerts of the same type usually occur one after another. If the correlation index between two alert clusters is above a dynamic threshold, then the two clusters are considered related. A description of the algorithm used to compute the alert correlation graph is in Section 6. The final output of the proposed algorithm for multistep alert correlation is represented by a set of directed graphs. Each graph represents a different attack scenario, whose vertices are clusters of similar alerts. The directed edges represent relationships between different alert clusters that belong to the same scenario. An example of graph produced by our algorithm is presented in Section 7.

4

Self-Organizing Map

A Self-Organizing Map is an auto-associative neural network [6], that is commonly used to produce a low-dimensional (typically two-dimensional) representation of input vectors that belong to a high-dimensional input space. SOM networks are especially useful for the visualization of data with high dimensionality, since input vectors are mapped to coordinates in the output layer by a neighborhood function that preserves the topological properties of the input

6

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

space. Hence, input vectors that are close in the input space are mapped to near positions in the output layer of the SOM. Input similarity between any two input vectors is inversely proportional to the distance between their projections on the output layer. Given a SOM having K neurons in the input layer, and M × N on the output layer, the SOM is a completely connected network having K ˇ M ˇ N links, so that each input neuron is connected to each neuron of the output layer. The output layer itself can be completely connected (that is, M (M - 1) ˇ N (N - 1) links) or simply connected (each neuron is connected only to the closest ones on the same row and column, and possibly on the same diagonal). Each link from the input to the output layer has a weight that expresses the strength of that link. In the described implementation, each alert is modelled as a numerical normalized tuple provided to the input layer. As an example, the i - th alert xi is modelled as xi = (alertT ypei , srcIPi , dstIPi , srcP orti , dstP orti , timestampi ) (1) where alertT ypei is the alert type as identified by Snort, srcIPi and dstI Pi are its source and destination IP addresses, srcP orti and dstP orti are the source and destination port numbers, and timestampi is the time at which the alert has been issued. Each field is represented by a numerical value normalized in the range [0, 1]. The first step initializes the weights of the links between the input and the output layer. Being the involved training algorithm unsupervised, it is important to have an optimal weight initialization instead of a random initialization. This approach guarantees an acceptable associative accuracy in the least number of steps. The weight initialization algorithm used in this model is similar to that proposed in [12]. It involves a heuristics that aims to map on near points the items which are dimensionally or logically close, and on distant points the items which are dimensionally or logically distant. Let us consider the training space X = {x1 , ..., xh } for our network. We pick up the two vectors xa , xb  X, with xa = {xa1 , ..., xaK } and xb = {xb1 , ..., xbK } having the maximum K -dimensional Euclidean distance: xa , xb  X | d(xa , xb )  d(xi , xj ) i, j = 1..h where
K

(2)

d(xi , xj ) =
p=1

(xip - xjp )

2

(3)

The values of xa and xb are used for initializing the vectors of weights on the lower left, wM 1 = xa , and the upper right corner, w1N = xb . The idea is to map the two dimensionally most distant items on the opposite corners of the output layer. The values of the upper left corner weights vector w11 are then initialized by picking up the vector xc  X - {xa , xb } having the maximum distance from xa

Multistep Attack Detection and Alert Correlation

7

and xb . Finally, the vector xd  X - {xa , xb , xc } having the maximum distance from xa , xb , xc initializes the values of the bottom right corner wM N . After this process, we need to initialize the weights of the remaining neurons on the four edges through a linear interpolations, according to the following relations: N -j j-1 w1j = w1N + w11 for j = 2, ..., N - 1 (4) N -1 N -1 N -j j-1 wM N + wM 1 for j = 2, ..., N - 1 (5) wM j = N -1 N -1 i-1 M -i wi1 = wM 1 + w11 for i = 2, ..., M - 1 (6) M -1 M -1 M -i i-1 wM N + w1N for i = 2, ..., M - 1 (7) wiN = M -1 M -1 After this step, the remaining neurons are initialized through the following two-dimensional linear interpolation: wij = (j - 1)(i - 1) (j - 1)(M - i) wM N + w1N + (N - 1)(M - 1) (N - 1)(M - 1) (N - j )(i - 1) (N - j )(M - i) wM 1 + w11 (N - 1)(M - 1) (N - 1)(M - 1)

(8)

This heuristic-based initialization schema for the SOM reduces the number of steps to reach a good precision, and improves the accuracy of the network with respect to a random initialization schema with fewer training steps [12]. After the initialization of the weights, the network undergoes unsupervised and competitive training by using the same training set X = {x1 , ..., xh } used for the initialization. For each training vector xi  X, i = 1, ..., h, the algorithm finds the neuron that most likely "represents" it, that is, the neuron having the weights vector w Ż with the minimum distance from xi : ||xi - w Ż || = min ||xi - wjk || (9)

for j = 1, ..., M, k = 1...N and the operator || ˇ || representing the Euclidean distance. w Ż represents the "best" neuron associated to the training vector xi , that is, the one having the minimum weight distance from the input element xi . At the t-th learning step, the map weights are updated according to the following relation: wjk (t) = wjk (t - 1) +  (w Ż , wjk )(t) (xi - wjk (t - 1)) (10)

for j = 1, ..., M, k = 1, ..., N . The value of the function  is inversely proportional to the distance between the two neuron weights taken as their arguments. In Eq. 10 this value increases proportionally to the distance between the neuron at coordinates (i, j ) and w Ż . It expresses a kind of "influence" in the update steps over the training vector xi that augments as we approach the neuron having

8

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

weights w Ż . Considering two neurons with coordinates (x, y ) and (i, j ), for the purposes of this paper we use the following  function:  (wxy , wjk ) = 1 (|x - j | + |y - k |)4 + 1 (11)

The term in round parentheses at the denominator is the Manhattan distance between the coordinates of the two neurons. The idea behind this choice is to apply, at each learning step, some strong adjustments over the neurons that are relatively close to w Ż , and the maximum adjustments on w Ż itself, for which the  function value is 1. The following step consists in the definition of a learning rate for the network expressed in function of the learning step t. In many SOM applications, this value is high at the beginning of the learning phase, when the network is still more prone to errors, and it decreases monotonically as the learning phase continues. However, as discussed in [15], this approach makes the learning process too much dependent on the first learning vectors, and not suited to the high variable context of NIDS alert analysis. To mitigate this issue, in this paper we use a learning rate function (t) close to that proposed in [15] and shown in Figure 2: (t) = t t exp 1 - T T (12)

T is a parameter that expresses how fast the learning rate should tend to 0. A low value of T implies a faster learning process on a smaller training set, while a high value implies a slower process on a larger training set. The parameter T is computed as a function of two user-defined parameters: ­ C , that represents the "cutoff" threshold for the learning rate, i.e. the value under which the learning phase feedback becomes negligible; ­ tc , that is computed by solving the equation (tc ) = C . It represents the number of learning steps that should be taken before having a learning rate that equals the cutoff value, i.e. the number of steps after which the SOM network becomes nearly insensitive to further learning feedbacks. The parameter T in (t) representation given tc , is computed by solving (tc ) = C : tc tc e + log T = log (13) T C that is a logarithmic equation having T as a variable. Its approximated solution is tc e C T = exp W-1 - (14) C e where W-1 is the analytic continuation of the Lambert W function.

Multistep Attack Detection and Alert Correlation

9

Fig. 2. Plot of the function (t) that expresses the learning rate in function of the current learning step

An approximation of this function is computed through its Taylor series as proposed in [1]:
+

W-1 (z ) =
k=0

ľk pk

(15)

where p=- ľk = k-1 k+1 2(ez + 1) (16) (17) ľk-2  k -2 k ľk-1 + - - 2 4 2 k+1
k -1

k =
j =2

ľj ľk-j +1

(18) (19)

ľ0 = -1, ľ1 = 1, 0 = 2, 1 = -1

10

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

The first terms of the series (eq. 15) are 1 11 42 4 769 5 W-1 (z ) = -1 + p - p2 + p3 - p + p - ... 3 72 540 17280 (20)

The SOM is re-trained at regular intervals. The training phase, that is computationally expensive, is executed in a separated thread, as discussed in Section 7. On multi-core processors this feature allows us to execute this phase in parallel with analysis and at short time intervals (in our experiments, in the order of 30-60 seconds). After the learning phase, the network is ready to associate alerts provided as the normalized numeric tuples as shown in Eq. 1. The network has as many input neurons as the number of items in the alert tuple, and its output layer size M × N configured by the user.

5

Clustering algorithm

The next step is to apply a k -means clustering algorithm on the SOM output layer to extract possible information over distinct attack scenarios. Hence, we need to initialize k centers, for a fixed value of k . Let M × N be the size of the SOM output laver, and D be the data set containing all the pairs (i, j ), 1  i  M , 1  j  N , having at least one associated alert. We pick up the points xľ = (iľ , jľ ) and x = (i , j ) out of the dataset D as the points having the maximum Euclidean distance: xľ , x  D : ||xľ - x ||  ||xi - xj ||, 1  i, j  |D| (21)

These points identify the first two centers for the clustering algorithm. The third center is chosen as the point in the data set having the maximum distance from xľ and x , the fourth center as the point having the maximum distance from the three centers chosen so far, and so on. After the initialization step, each element in the data set D "chooses" the centers closest to it as the identifier of its cluster. Therefore, at the t-th iteration, (t) the set Si , containing the points associated to the i-th center, for 1  i  k , is defined as Si
(t) (t)

= xj : ||xj - mi ||  ||xj - mi || i = 1..k

(t)

(t)

(22)

where mi represents the coordinates of the i-th center at the step t. The centers of each cluster are the computed again as mean of the points inside of it: mi
(t+1)

=

1 |Si |
(t) (t) xj Si
(t)

xj

(23)

The algorithm is repeated until mi = mi i = 1, ..., k , that is, until no more change is needed on the coordinates of the centers.

(t+1)

Multistep Attack Detection and Alert Correlation

11

A well known drawback of the k -means algorithm consists in the necessity to fix the value of the number of clusters k before the algorithm execution. To limit this risk, we use the Schwarz criterion [10] as our heuristics for computing the best number of clusters in our data set. In particular, for 1  k  |D|, we compute several heuristic indexes that express, for that value of k , how large is the distortion value for that k , that is how large the average distance between each point and its associated center is: ľk = k log n +
xj D

(xj - mi )2

(24)

where mi , 1  i  k , is the center associated by the k -means algorithm to the generic point xj  D. The best value of k , k  , is the one having ľk  ľk , k = 1...|D|. The Schwarz heuristic allows us to build a clustering algorithm based on a near-optimal number of clusters without using fixed or user-provided parameters. This approach is able to adapt itself to the heterogeneity of the data set at the price of a higher computational cost.

6

Correlation index

In the last processing step we compute correlations among alert clusters belonging to the same attack scenario. The correlation index between two alert clusters Ai and Aj mapped on two output neurons having coordinates (x[Ai ], y [Ai ]) and (x[Aj ], y [Aj ]) is computed as a function of the Euclidean distance between these two neurons normalized over the maximum distance on the output matrix, that is the distance between the extreme points on the same diagonal (denoted by (x0 , y0 ) and (xM , yM )): 0, Corr(Ai , Aj ) = 
1+ 1 , (x[Ai ]-x[Aj ])2 +(y [Ai ]-y [Aj ])2

1] 2]

(25)

The case 1] comes when the distance between (x[Ai ], y [Ai ]) and (x[Aj ], y [Aj ]) is the same distance between (x0 , y0 ) and (xM , yM ), that is, the two alerts are mapped on neurons having the maximum distance (in this case their correlation value is zero), otherwise we have the case 2]. The correlation value between two alerts is always normalized in [0, 1]. This definition of correlation is commutative, and it does not express any causality correlation. As we want to express the direction of the causality between two alerts, a of type A and b of type B with a relatively high correlation coefficient, we pursue the following approach: 1. If t[b] > t[a], i.e. the alert b was raised after the alert a, and we have no historical information over time relations between alerts of type A and alerts of type B , then a - b, that is the alert a was likely to generate the alert b in a specific attack scenario;

12

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

2. If we have logged information over alerts of both types A and B , and the number of times that an alert of type B occurred after an alert of type A (in a specified time window) is greater than the number of times when the opposite event occurred, then a - b. The weight of this correlation value (denoting its accuracy), is computed as a function of the size of the knowledge base acquired so far, namely the number of alerts in the alert log L used to train the SOM. In particular, we want to keep a relatively low weight (close to 0) when the size of the alert log used for training the network is small, and to increase it when the system acquires new alerts. Given an alert log of size x = |L|, we compute the weight w(x) of the SOM-based index through a monotonically increasing function in [0, 1]. In particular, we will use the hyperbolic tangent tanh as the weight function: w(x) = tanh x K = e K - e- K x x e K + e- K
x x

(26)

The parameter K determines how fast we want the algorithm to tend to 1. It is set as a function of the parameter xM denoting the size of the alert log L in order to have w(xM ) = M . In this paper we use M = 0.95. Considering 1 as the asymptotically maximum value for w(x), then xM denotes the size of the alert log L in order to have a weight that is 95% of its maximum value): w(xM ) = M - e e
xM K xM K

- e- + e-

xM K xM K

=M

(27)

Solving this equation through numerical approximation methods, for a fixed value of M and letting t = xM /K , we get an approximated solution tsol , used for computing K as: K= xM tsol (28)

Once obtained the correlation coefficients for each pair of alerts, we consider two alerts Ai , Aj actually correlated only if their correlation value is greater than a threshold: is corr(Ai , Aj ) = true  Corr(Ai , Aj )  ľcorr + corr (29)

where ľcorr is the average correlation value and corr is its standard deviation.   R denotes how far from the average we want to shift in order to consider two alerts as correlated. Feasible values of  for our purposes are in the interval   [0, 2]. For  0 we consider as correlated all the pairs of alerts having a correlation value higher than the average one. This usually implies a relatively large correlation graph. A value of  2 brings to a smaller correlation graph, that only contains the most strongly correlated pairs of alerts. Higher values for  could result in empty or poorly populated correlation graphs, since the correlation constraint could be too strict.

Multistep Attack Detection and Alert Correlation

13

7

Experimental results

We carried out several experiments using a prototype implementation of the proposed multistep alert correlation architecture. The software has been mainly developed in C, as a module for Intrusion Detection System software Snort. It also includes a Web-based user interface realized in Perl, HTML and AJAX. A preliminary set of experiments, aiming to verify all the funcionalities of our software, were conducted using small-scale traffic traces, including attack scenarios performed within controlled network environment. Extensive experimental evaluation have then been carried out against the Capture the Flag (CTF) 2010 dataset, that includes 40 GB of network traffic in PCAP format and is publicly available [4]. Our goals are to demonstrate that the computational cost of the proposed solution is compatible with live traffic analysis and to verify the capability of the system to recongize and correlate alerts belonging to the same attack scenario. To achieve high performance, several different processing steps have been implemented as concurrent threads, that run in parallel with traffic analysis. In particular, alert clustering, training of the SOM and the periodic evaluation of the best value of k of the k -means algorithm, are performed in the background. As soon as the new weight of the SOM or the new best value of k are computed, they are substituted to the previous values. This design choice allows us to leverage modern, multi-core architectures to perform these expensive operations with no impacts on the overall performance of Snort. The two lines in Figure 3 show the memory usage of Snort while analyzing a 200MB traffic trace with and without or multistep alert correlation module. When our module is active, the memory usage of Snort is slightly higher. However, in both the cases the analysis of the traffic dump requires about 42 seconds, hence or module has no noticeable impact on the time required to analyze the traffic trace. Thanks to the self-adaptive choices of the parameters, our framework can easily adapt to heterogeneous traffic traces without the need for user-defined static configurations: ­ the first alert clustering phase [5] is performed using the average heterogeneity of the alerts as grouping measure; ­ the SOM distances depend on the size of the SOM network itself, but a greater size means a higher average distance, that anyway does not impact on the relative normalized distance values; ­ The k -means clustering uses Schwarz criterion as heuristic for computing the best number of data clusters. The last processing step, that computes the correlation index among clustered alerts belonging to the same attack scenario, is quite sensitive to the choice of the parameter  in Eq. 29. Feasible values are in the interval   [0, 2], as discussed in Section 6. A value of  close to zero produces a graph that contains many alert correlations (all the ones having a correlation value greater than the average one). This is useful when the user wants to know all the likely correlations. A value

14

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

Fig. 3. Memory usage of Snort analyzing 200 MB of CTF traffic, with and without our module

closer to 2 highlights the few "strongest" correlations, having high correlation values. For example, by setting  = 1.7, we obtain 4 different scenarios, two of which are reported in Figures 4 and 5. The scenario represented by the correlation graph in Figure 4 contains a likely shellcode execution (the grouping of several similar alerts inside of the same graph node is performed through Julisch method described in [5]) linked to an HTTP LONG HEADER alert and to a NON-RFC DEFINED CHAR alert raised by the http inspect module towards the same host and port in the same time window. The correlation graph depicted in Figure 5 represents an attack scenario in which a TCP portsweep alert and an ICMP sweep alert triggered towards the same subnet in the same time window are successfully correlated. On the other hand, by setting  = 1.2 we obtain a larger number of likely scenarios, that can also be connected among them. The XML file1 containing the 37 alert clusters that represent different attack scenarios and the corresponding correlation graphs 2 cannot be included and discussed in this paper for space limitations and are freely available online.
1 2

Available online at http://cris.unimore.it/files/attack_scenarios.xml Available online at http://cris.unimore.it/files/correlation_graph.png

Multistep Attack Detection and Alert Correlation

15

Fig. 4. Example of a correlation sub-graph generated by the software using the Capture the Flag 2010 dataset, successfully finding a correlation in a scenario containing a shellcode NOOP alert and a HTTP LONG HEADER alert on the same port and in the same time window

Fig. 5. Another example of a correlation found by the software, showing a correlation between some TCP portsweep and ICMP sweep alerts towards the same subnet and in the same time window

8

Conclusion

This paper presents a novel multistep alert correlation algorithm that is able to group security alerts belonging to the same attack scenario and to identify correlations and casual relationships among intrusions activities. The input of the proposed algorithm is represented by security alerts generated by a signaturebased NIDS, such as Snort. Viability and efficacy of the proposed multistep alert correlation algorithm is demonstrated through a prototype, tested against recent and publicly available traffic traces. Experimental results show that the proposed multistep correlation algorithm is able to isolate and correlate intrusion activities belonging to the same attack scenario, thus helping security administrator in the analysis of alerts produced by a NIDS. Moreover, by leveraging modern multi-

16

Fabio Manganiello, Mirco Marchetti, and Michele Colajanni

core architectures to perform training in parallel and non-blocking threads, the computational cost of our prototype is compatible with live traffic analysis.

References
1. Chapeau-Blondeau, F.: Numerical evaluation of the lambert w function and application to generation of generalized gaussian noise with exponent 1/2. IEEE Transactions on Signal Processing 50(9) (2002) 2. Chen, Z.G., Zhang, G.H., Tian, L.Q., Geng, Z.L.: Intrusion detection based on self-organizing map and artificial immunisation algorithm. Engineering Materials 439(1), 29­34 (2010) 3. Colajanni, M., Marchetti, M., Messori, M.: Selective and early threat detection in large networked systems. In: Proc. of the 10th IEEE International Conference on Computer and Information Technology (CIT 2010) (2010) 4. Capture the flag traffic dump, available online at http://www.defcon.org/html/ links/dc-ctf.html 5. Julisch, K.: Clustering intrusion detection alarms to support root cause analysis. ACM Transactions on Information and System Security 6, 443­471 (2003) 6. Kohonen, T.: The self-organizing map 78(9) (1990) 7. Mukkamala, S., Janoski, G., Sung, A.: Intrusion detection using neural networks and support vector machines. In: Proceedings of the 2002 International Joint Conference on Neural Networks (2002) 8. Munesh, K., Shoaib, S., Humera, N.: Feature-based alert correlation in security systems using self organizing maps. In: Proceedings of SPIE, the International Society for Optical Engineering (2009) 9. Patole, V.A., Pachghare, V.K., Kulkarni, P.: Article: Self organizing maps to build intrusion detection system. International Journal of Computer Applications 1(7), 1­4 (February 2010) 10. Pelleg, D., Moore, A.: X-means: Extending k-means with efficient estimation of the number of clusters. In: Proc. of the 17th International Conference on Machine Learning. pp. 727­734. Morgan Kaufmann (2000) 11. Snort home page, available online at http://www.snort.org 12. Su, M.C., Liu, T.K., Chang, H.T.: Improving the self-organizing feature map algorithm using an efficient initialization scheme. Tamkang Journal of Science and Engineering 5(1), 35 ­ 48 (2002) 13. Valeur, F., Vigna, G., Kruegel, C., Kemmerer, R.A.: A comprehensive approach to intrusion detection alert correlation. IEEE Transactions on Dependable and Secure Computing 1, 146­169 (2004) 14. Vokorokos, L., Bal´ az, A., Chovanec, M.: Intrusion detection system using self organizing map 6(1) (2006) 15. Yoo, J.H., Kang, B.H., Kim, J.W.: A clustering analysis and learning rate for selforganizing feature map. In: Proc. of the 3rd International Conference on Fuzzy Logic, Neural Networks and Soft Computing (1994)

