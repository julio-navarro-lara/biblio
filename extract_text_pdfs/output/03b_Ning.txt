Learning Attack Strategies from Intrusion Alerts
Peng Ning
Cyber Defense Laboratory Department of Computer Science North Carolina State University Raleigh, NC 27695-8207



Dingbang Xu
Cyber Defense Laboratory Department of Computer Science North Carolina State University Raleigh, NC 27695-8207

ning@csc.ncsu.edu ABSTRACT
Understanding strategies of attacks is crucial for security applications such as computer and network forensics, intrusion response, and prevention of future attacks. This paper presents techniques to automatically learn attack strategies from correlated intrusion alerts. Central to these techniques is a model that represents an attack strategy as a graph of attacks with constraints on the attack attributes and the temporal order among these attacks. To learn the intrusion strategy is then to extract such a graph from a sequences of intrusion alerts. To further facilitate the analysis of attack strategies, which is essential to many security applications such as computer and network forensics, this paper presents techniques to measure the similarity between attack strategies. The basic idea is to reduces the similarity measurement of attack strategies into errortolerant graph/subgraph isomorphism problem, and measures the similarity between attack strategies in terms of the cost to transform one strategy into another. Finally, this paper presents some experimental results, which demonstrate the potential of the proposed techniques.

dxu@unity.ncsu.edu 1. INTRODUCTION
It has become a well-known problem that current intrusion detection systems (IDSs) produce large volumes of alerts, including both actual and false alerts. As the network performance improves and more network-based applications are being introduced, the IDSs are generating increasingly overwhelming alerts. This problem makes it extremely challenging to understand and manage the intrusion alerts, let alone respond to intrusions timely. It is often desirable, and sometimes necessary, to understand attack strategies in security applications such as computer forensics and intrusion responses. For example, it is easier to predict an attacker's next move, and decrease the damage caused by intrusions, if the attack strategy is known during intrusion response. However, in practice, it usually requires that human users analyze the intrusion data manually to understand the attack strategy. This process is not only time-consuming, but also error-prone. An alternative is to enumerate and reason about attack strategies through static vulnerability analysis (e.g., [1, 19, 33, 35]). However, these techniques usually require predefined security properties so that they can identify possible attack sequences that may lead to violation of these properties. Although it is easy to specify certain security properties such as compromise of root privilege, it is non-trivial to enumerate all possible ones. Moreover, analyzing strategies from intrusion alerts allows inspecting actual executions of attack strategies with different levels of details, providing additional information not available in static vulnerability analysis. Thus, it is desirable to have complementary techniques that can profile attack strategies from intrusion alerts. In this paper, we present techniques to automatically learn attack strategies from intrusion alerts reported by IDSs. Our approach is based on the recent advances in intrusion alert correlation [9, 29]. By examining correlated intrusion alerts, our method extracts the constraints intrinsic to the attack strategy automatically. Specifically, an attack strategy is represented as a directed acyclic graph (DAG), which we call an attack strategy graph, with nodes representing attacks, edges representing the (partial) temporal order of attacks, and constraints on the nodes and edges. These constraints represent the conditions that any attack instance must satisfy in order to use the strategy. To cope with variations in attacks, we use generalization techniques to hide the differences not intrinsic to the attack strategy. By controlling the degree of generalization, users may inspect attack strategies at different levels of details. To facilitate intrusion analysis in applications such as computer and network forensics, we further develop a method to measure the similarity between intrusion alert sequences based on their strategies. Similarity measurement of alert sequences is a fundamental problem in many security applications such as profiling hackers or hacking tools, identification of undetected attacks, attack predic-

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection--Invasive software (e.g., viruses, worms, Trojan horses); K.6.5 [Management of Computing and Information Systems]: Security and Protection

General Terms
Security, Performance

Keywords
intrusion detection, profiling attack strategies, alert correlation
 The authors would like to thank Dr. Bruno T. Messmer for allowing us to use his graph matching tool (GUB). The authors would also like to thank the anonymous reviewers for their valuable comments. This work is partially supported by the National Science Foundation (NSF) under grants CCR-0207297 and ITR0219315, and by the U.S. Army Research Office (ARO) under grant DAAD19-02-1-0219.

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. CCS'03, October 27­31, 2003, Washington, DC, USA. Copyright 2003 ACM 1-58113-738-9/03/0010 ...$5.00.

tion, and so on. To achieve this goal, we harness the results on error tolerant graph/subgraph isomorphism detection in the pattern recognition field. By analyzing the semantics and constraints in similarity measurement of alert sequences, we transform this problem into error tolerant graph/subgraph isomorphism detection. Our contribution in this paper is three-fold. First, we develop a model to represent attack strategies as well as algorithms to extract attack strategies from correlated alerts. Second, we develop techniques to measure the similarity between sequences of alerts on the basis of the attack strategy model. Third, we perform a number of experiments to validate the proposed techniques. Our experimental results show that our techniques can successfully extract invariant attack strategies from sequences of alerts, measure the similarity between alert sequences conforming to human intuition, and identify attacks possibly missed by IDSs. The remainder of this paper is organized as follows. The next section presents a model to represent and extract attack strategies from a sequence of correlated intrusion alerts. Section 3 discusses the methods to measure the similarity between sequences of related alerts based on their strategies. Section 4 presents the experiments we perform to validate the proposed methods. Section 5 discusses the related work, and Section 6 concludes this paper.

67432 67434 67343 67436 Sadmind_Ping 67440 Sadmind_Amslverify_Overflow Rsh 67558 67560 67559 67553

Attacking Host: 202.77.162.213 Victim Host: 172.16.112.50 67554 67773 67776 Mstream_Zombie Stream_DoS

Figure 1: An example of hyper-alert correlation graph must evaluate to True and all the logical formulas in consequence might evaluate to True for each of the tuples. The correlation process is to identify the prepare-for relations between hyper-alerts. Intuitively, it is to check if an earlier hyperalert contributes to the prerequisite of a later one. In the formal model, this is performed through the notions of prerequisite and consequence sets. Consider a hyper-alert type T = (fact, prerequisite, consequence). The prerequisite set (or consequence set) of T , denoted P rereq (T ) (or Conseq (T )), is the set of all predicates that appear in prerequisite (or consequence). Moreover, the expanded consequence set of T , denoted ExpConseq (T ), is the set of all predicates that are implied by Conseq (T ). Thus, Conseq (T )  ExpConseq (T ). This is computed using the implication relationships between predicates [29]. Given a type T hyper-alert h, the prerequisite set, consequence set, and expanded consequence set of h, denoted P rereq (h), Conseq (h), and ExpConseq (h)), respectively, are the predicates in P rereq (T ), Conseq (T ), and ExpConseq (T ) whose arguments are replaced with the corresponding attribute values of each tuple in h. Each element in P rereq (h), Conseq (h), or ExpConseq (h) is associated with the timestamp of the corresponding tuple in h. Hyper-alert h1 prepares for hyperalert h2 if there exist p  P rereq (h2 ) and c  ExpConseq (h1 ) such that p = c and c.end time < p.begin time. We use a hyper-alert correlation graph to represent a set of correlated alerts. A hyper-alert correlation graph CG = (N , E ) is a connected directed acyclic graph (DAG), where N is a set of hyperalerts, and for each pair n1 , n2  N , there is a directed edge from n1 to n2 in E if and only if n1 prepares for n2 . Figure 1 shows a hyper-alert correlation graph adapted from [29]. The numbers inside the nodes represent the alert IDs, and the types of alerts are marked below the corresponding nodes. Limitations of the correlation model. The correlation model can be used to construct attack scenarios (represented as hyper-alert correlation graphs) from intrusion alerts. Although such attack scenarios reflect attack strategies, they do not capture the essence of the strategies. Indeed, even with the same attack strategy, if an attacker changes certain details during attacks, the correlation model will generate different hyper-alert correlation graphs. For example, an attacker may repeat (unnecessarily) one step in a sequence of attacks many times, and the correlation model will generate a much more complex attack scenario. As another example, if an attacker uses equivalent, but different attacks, the correlation model will generate different hyper-alert correlation graphs as well. It is then up to the user to figure out manually the common strategy used in two sequences of attacks. This certainly increases the overhead in intrusion alert analysis.

2.

MODELING ATTACK STRATEGIES

In this section, we present a method to represent and automatically learn attack strategies from a sequence of related intrusion alerts. Our techniques are developed on the basis of our previous work on alert correlation [29], which we refer to as the correlation model in this paper. In the following, we first give a brief overview of the correlation model, and then discuss our new techniques.

2.1 Overview of the Correlation Model
The correlation model was developed to reconstruct attack scenarios from alerts reported by IDSs. It is based on the observation that "most intrusions are not isolated, but related as different stages of attacks, with the early stages preparing for the later ones" [29]. The model requires the prerequisites and consequences of intrusions. The prerequisite of an intrusion is the necessary condition for the intrusion to be successful. For example, the existence of a vulnerable ftp service is the prerequisite of a ftp buffer overflow attack against this service. The consequence of an intrusion is the possible outcome of the intrusion. For example, gaining local access as root from a remote machine may be the consequence of a ftp buffer overflow attack. This method then correlates two alerts if the consequence of the earlier alert prepares for the prerequisites of the later one. The correlation method uses logical formulas, which are logical combinations of predicates, to represent the prerequisites and consequences of intrusions. For example, a scanning attack may discover UDP services vulnerable to certain buffer overflow attacks. Then the predicate UDPVulnerableToBOF (VictimIP, VictimPort) may be used to represent this discovery. The correlation model formally represents the prerequisites and consequences of known attacks as hyper-alert types. A hyper-alert type is a triple (fact, prerequisite, consequence), where fact is a set of alert attribute names, prerequisite is a logical formula whose free variables are all in fact, and consequence is a set of logical formulas such that all the free variables in consequence are in fact. Intuitively, a hyper-alert type encodes the knowledge about the corresponding attacks. Given a hyper-alert type T = (fact, prerequisite, consequence), a type T hyper-alert h is a finite set of tuples on fact, where each tuple is associated with an interval-based timestamp [begin time, end time]. The hyper-alert h implies that prerequisite

2.2 Attack Strategy Graph
In the following, we present a model to represent and automatically extract attack strategies from correlated alerts. The goal of this model is to capture the invariants in attack strategies that do not change across multiple instances of attacks. The strategy behind a sequence of attacks is indeed about how to arrange earlier attacks to prepare for the later ones so that the attacker can reach his/her final goal. Thus, the prepare for rela-

tions between the intrusion alerts (i.e., detected attacks) is intrinsic to attack strategies. However, in the correlation model, the prepare for relations are between specific intrusion alerts; they do not directly capture the conditions that have to be met by related attacks. To facilitate the representation of the invariant attack strategy, we transform the prepare for relation into some common conditions that have to be satisfied by all possible instances of the same strategy. In the following, we formally represent such a condition as an equality constraint. D EFINITION 1. Given a pair of hyper-alert types (T1 , T2 ), an equality constraint for (T1 , T2 ) is a conjunction of equalities in the form of u1 = v1  ˇ ˇ ˇ  un = vn , where u1 , ˇ ˇ ˇ , un are attribute names in T1 and v1 , ˇ ˇ ˇ , vn are attribute names in T2 , such that there exist p(u1 , ˇ ˇ ˇ , un ) and p(v1 , ˇ ˇ ˇ , vn ), which are the same predicate with possibly different arguments, in ExpConseq (T1 ) and P rereq (T2), respectively. Given a type T1 hyper-alert h1 and a type T2 hyper-alert h2 , h1 and h2 satisfy the equality constraint if there exist t1  h1 and t2  h2 such that t1 .u1 = t2 .v1  ˇ ˇ ˇ  t1 .un = t2 .vn evaluates to True. There may be several equality constraints for a pair of hyperalert types. However, if a type T1 hyper-alert h1 prepares for a type T2 hyper-alert h2 , then h1 and h2 must satisfy at least one of the equality constraints. Indeed, h1 preparing for h2 is equivalent to the conjunction of h1 and h2 satisfying at least one equivalent constraint and h1 occurring before h2 . Assume that h1 occurs before h2 . If h1 and h2 satisfy an equality constraint for (T1 , T2 ), then by Definition 1, there must be a predicate p(u1 , ˇ ˇ ˇ , un ) in ExpConseq (T1 ) such that the same predicate with possibly different arguments, p(v1 , ˇ ˇ ˇ , vn ), is in P rereq (T2 ). Since h1 and h2 satisfy the equality constraint, p(u1 , ˇ ˇ ˇ , un ) and p(v1 , ˇ ˇ ˇ , vn ) will be instantiated to the same predicate in ExpConseq (h1 ) and P rereq (h2 ). This implies that h1 prepares for h2 . Similarly, if h1 prepares for h2 , there must be an instantiated predicate that appears in ExpConseq (h1 ) and P rereq (h2 ). This implies that there must be a predicate with possibly different arguments in ExpConseq (T1 ) and P rereq (T2 ) and that this predicate leads to an equality constraint for (T1 , T2 ) satisfied by h1 and h2 . E XAMPLE 1. The notion of equality constraint can be illustrated with an example. Consider the following hyper-alert types: SadmindPing = ({VictimIP, VictimPort}, ExistsHost(VictimIP), {VulnerableSadmind (VictimIP)}), and SadmindBufferOverflow = ({VictimIP, VictimPort}, ExistHost (VictimIP)  VulnerableSadmind (VictimIP), {GainRootAccess (VictimIP)}). The first hyper-alert type indicates that SadmindPing is a type of attacks that requires the existence of a host at the VictimIP, and as a result, the attacker may find out that this host has a vulnerable Sadmind service. The second hyper-alert type indicates that this type of attacks requires a vulnerable Sadmind service at the VictimIP, and as a result, the attack may gain root access. Obviously, the predicate V ulnerableSadmind is in both P rereq (SadmindBuf f erOverf low) and ExpConseq (SadmindP ing ). Thus, we have an equality constraint V ictimIP = V ictimIP for (SadmindPing, SadmindBufferOverflow), where the first VictimIP comes from SadmindPing, and the second VictimIP comes from SadmindBufferOverflow. We observe many times that one step in a sequence of attacks may trigger multiple intrusion alerts, and the number of alerts may vary in different situations. This is partially due to the existing vulnerabilities and the hacking tools. For example, unicode shell [31], which is a hacking tool against Microsoft IIS web server, checks about 20 vulnerabilities at the scanning stage and usually triggers the same number of alerts. As another example, in the attack scenario reported in [29], the attacker tried 3 different stack pointers and 2 commands in Sadmind Amslverify Overflow attacks

Ł¤ĽŚ§ Ľ §  Ł¤ĽŚ§ Ľ Ś !"#§$% "#$!'( 12 ¨Š ¨ ¨&   Ą   ˘   ˘   ) Ł#0     Š Š  Š Š   )  Ą  ˘

4 #¤Ś 'Ś6§  Ł#¤Ś ' ¨5 ¨  ) Ł#0  3 Ł#0   Š  Š   3   7

Figure 2: An example of attack strategy graph for each victim host until one attempt succeeded. Even if not necessary, an attacker may still deliberately repeat the same step multiple times to confuse IDSs and/or system administrators. However, such variations do not change the corresponding attack strategy. Indeed, these variations make the attack scenarios unnecessarily complex, and may hinder manual or automatic analysis of the attack strategy. Thus, we decide to disallow such situations in our representation of attack strategies. In the following, an attack strategy is formally represented as an attack strategy graph. D EFINITION 2. Given a set S of hyper-alert types, an attack strategy graph over S is a quadruple (N, E, T, C ), where (1) (N, E ) is a connected DAG (directed acyclic graph); (2) T is a mapping that maps each n  N to a hyper-alert type in S ; (3) C is a mapping that maps each edge (n1 , n2 )  E to a set of equality constraints for (T (n1 ), T (n2 )); (4) For any n1 , n2  N , T (n1 ) = T (n2 ) implies that there exists n3  N such that T (n3 ) = T (n1 ) and n3 is in a path between n1 and n2 . In an attack strategy graph, each node represents a step in a sequence of related attacks. Each edge (n1 , n2 ) represents that a type T (n1 ) attack is needed to prepare for a successful type T (n2 ) attack. Each edge may also be associated with a set of equality constraints satisfied by the intrusion alerts. These equality constraints indicate how one attack prepares for another. Finally, as represented by condition 4 in Definition 2, same type of attacks should be considered as one step, unless they depend on each other through other types of attacks. Now let us see an example of an attack strategy graph. E XAMPLE 2. Figure 2 is the attack strategy graph extracted from the hyper-alert correlation graph in Figure 1. The hyper-alert types are marked above the corresponding nodes, and the equality constraints are labeled near the corresponding edges. This attack strategy graph clearly shows the component attacks and the constraints that the component attacks must satisfy.

2.2.1 Learning Attack Strategies
As discussed earlier, our goal is to learn attack strategies automatically from correlated intrusion alerts. This requires we extract the constraints intrinsic to attack strategy from alerts so that the constraints apply to all instances of the same strategy. Our strategy to achieve this goal is to process the correlated intrusion alerts in two steps. First, we aggregate intrusion alerts that belong to the same step of a sequence of attacks into one hyperalert. For example, in Figure 1, alerts 67432, 67434, 67436, and 67440 are indeed attempts of the same attack with different parameters, and thus they should be aggregated as one step in the attack sequence. Second, we extract the constraints between the attack steps and represent them as an attack strategy graph. For example, after we aggregate the hyper-alerts in the first step, we may extract the attack strategy graph shown in Figure 2. The challenge lies in the first step. Because of the variations of attacks as well as the signatures that IDSs use to recognize attacks, there is no clear way to identify intrusion alerts that belong to the same step in a sequence of attacks. In the following, we first attempt to use the attack type information to do so. The notion of aggregatable hyper-alerts is introduced formally to clarify when the same type of hyper-alerts can be aggregated. D EFINITION 3. Given a hyper-alert correlation graph CG = (N, E ), a subset N  N is aggregatable, if (1) all nodes in N

Algorithm 1. ExtractStrategy Input: A hyper-alert correlation graph CG. Output: An attack strategy graph ASG. Method: 1. Let CG = GraphReduction (CG). 2. Let ASG = (N, E, T, C ) be an empty attack strategy graph. 3. for each hyper-alert h in CG 4. Add a new node, denoted nh , into N and set T (nh ) be the type of h. 5. for each edge (h, h ) in CG 6. Add (nh , nh ) into E . 7. for each pc  ExpConseq (h) and pp  P rereq (h ) 8. if pc = pp then 9. Add into C (nh , nh ) the equality constraint (u1 = v1 )  ˇ ˇ ˇ  (un = vn ), where ui and vi are the ith variable of pc and pp before instantiation, resp. 10. return ASG(N, E, T, C ). Subroutine GraphReduction Input: A hyper-alert correlation graph CG = (N, E ). Output: An irreducible hyper-alert correlation graph CG = (N , E ). Method: 1. Partition the hyper-alerts in N into groups such that the same type of hyper-alerts are all in the same group. 2. for each group G 3. if there is a path g, n1 , ˇ ˇ ˇ , nk , g in CG such that only g and g in this path are in G then 4. Divide G into G1 , G2 , and G3 such that all hyper-alerts in G1 occur before n1 , all hyper-alerts in G3 occur after nk , and all the other hyper-alerts are in G2 . 5. Repeat steps 2 to 4 until no group can be divided. 6. Aggregate the hyper-alerts in each group into one hyper-alert. 7. Let N be the set of aggregated hyper-alerts. 8. for all n1 , n2  N 9. if there exists (h1 , h2 )  E and h1 and h2 are aggregated into n1 and n2 , resp. 10. add (n1 , n2 ) into E . 11. return CG = (N , E ).

and the rest of the algorithm extracts the components of the output attack strategy graph. The steps in this algorithm are selfexplanatory; we do not repeat them in the text. Lemma 1 ensures that the output of algorithm 1 indeed satisfies the constraints of an attack strategy graph. L EMMA 1. The output of Algorithm 1 is an attack strategy graph.

2.3 Dealing with Variations of Attacks
Algorithm 1 in Figure 3 has ignored equivalent but different attacks in sequences of attacks. For example, an attacker may use either pmap dump or Sadmind Ping to find a vulnerable Sadmind service. As another example, an attacker may use either SadmindBufferOverflow or TooltalkBufferOverflow attack to gain remote access to a host. Obviously, at the same stage of two sequences of attacks, if an attacker uses equivalent but different attacks, Algorithm 1 will return two different attack strategy graphs, though the strategies behind them are the same. We propose to generalize hyper-alert types so that the syntactic difference between equivalent hyper-alert types is hidden. For example, we may generalize both SadmindBufferOverflow and TooltalkBufferOverflow attacks into RPCBufferOverflow. A generalized hyper-alert type is created to hide the unnecessary difference between specific hyper-alert types. Thus, an occurrence of any of the specific hyper-alerts should imply an occurrence of the generalized one. This is to say that satisfaction of the prerequisite of a specific hyper-alert implies the satisfaction of the prerequisite of the generalized hyper-alert. Moreover, to cover all possible impact of all the specific hyper-alerts, the consequences of all the specific hyper-alert types should be included in the consequence of the generalized hyper-alert type. It is easy to see that this generalization may cause loss of information. Thus, generalization of hyper-alert types must be carefully handled so that information essential to attack strategy is not lost. In the following, we formally clarify the relationship between specific and generalized hyper-alert types. D EFINITION 5. Given two hyper-alert types Tg and Ts , where Tg = (f actg , prereqg , conseqg ) and Ts = (f acts , prereqs , conseqs ), we say Tg is more general than Ts (or, equivalently, Ts is more specific than Tg ) if there exists an injective mapping f from f actg to f acts such that the following conditions are satisfied: ˇ If we replace all variables x in prereqg with f (x), prereqs implies prereqg , and ˇ If we replace all variables x in conseqg with f (x), then all formulas in conseqs are implied by conseqg . The mapping f is called the generalization mapping from Ts to Tg . E XAMPLE 3. Suppose hyper-alert types SadmindBufferOverflow and TooltalkBufferOverflow are specified as follows: SadmindBufferOverflow = ({VictimIP, VictimPort}, ExistHost (VictimIP)  VulnerableSadmind (VictimIP), {GainRootAccess (VictimIP)}), and TooltalkBufferOverflow = ({VictimIP, VictimPort}, ExistHost (VictimIP)  VulnerableTooltalk (VictimIP), {GainRootAccess (VictimIP)}). Assume that VulnerableSadmind (VictimIP) imply VulnerableRPC (VictimIP). Intuitively, this represents that if there is a vulnerable Sadmind service at VictimIP, then there must be a vulnerable RPC service (i.e., the Sadmind service) at VictimIP. Similarly, we assume VulnerableTooltalk (VictimIP) also implies VulnerableRPC (VictimIP). Then we can generalize both SadmindBufferOverflow and TooltalkBufferOverflow into RPCBufferOverflow = ({VictimIP}, ExistHost (VictimIP)  VulnerableRPC (VictimIP), {GainRootAccess (VictimIP)}), where the generalization mapping is f (V ictimIP ) = V ictimIP .

Figure 3: Extract attack strategy graph from a hyper-alert correlation graph are the same type of hyper-alerts, and (2) n1 , n2  N , if there is a path from n1 to n2 , then all nodes in this path must be in N . Intuitively, in a hyper-alert correlation graph, where intrusion alerts have been correlated together, the same type of hyper-alerts can be aggregated as long as they are not used in different stages in the attack sequence. Condition 1 in Definition 3 is quite straightforward, but condition 2 deserves more explanation. Consider the same type of hyper-alerts h1 and h2 . If h1 prepares for a different type of hyper-alert h (directly or indirectly), and h further prepares for h2 (directly or indirectly), h1 and h2 obviously belong to different steps in the same sequence of attacks. Thus, we shouldn't allow them to be aggregated together. Although we have never observed such situations, we cannot rule out such possibilities. Based on the notion of aggregatable hyper-alerts, the first step in learning attack strategy from a hyper-alert correlation graph is quite straightforward. We only need to identify and merge all aggregatable hyper-alerts. To proceed to the second step in strategy learning, we need a hyper-alert correlation graph in which each hyper-alert represents a separate step in the attack sequence. Formally, we call such a hyper-alert correlation graph an irreducible hyper-alert correlation graph. D EFINITION 4. A hyper-alert correlation graph CG = (N, E ) is irreducible if for all N  N , where |N | > 1, N is not aggregatable. Figure 3 shows the algorithm to extract attack strategy graphs from hyper-alert correlation graphs. The subroutine GraphReduction is used to generate an irreducible hyper-alert correlation graph,

By identifying a generalization mapping, we can specify how a specific hyper-alert can be generalized into a more general hyperalert. Following the generalization mapping, we can find out what attribute values of a specific hyper-alert should be assigned to the attributes of the generalized hyper-alert. The attack strategy learning algorithm can be easily modified: We first generalize the hyperalerts in the input hyper-alert correlation graph into generalized hyper-alerts following the generalization mapping, and then apply Algorithm 1 to extract the attack strategy graph. Although a hyper-alert can be generalized in different granularities, it is not an arbitrary process. In particular, if one hyper-alert prepares for another hyper-alert before generalization, the generalized hyper-alerts should maintain the same relationship. Otherwise, the dependency between different attack stages, which is intrinsic in an attack strategy, will be lost. The remaining challenge is how to get the "right" generalized hyper-alert types and generalization mappings. The simplest way is to manually specify them. For example, Apache2, Back, and Crashiis are all Denial of Service attacks. We may simply generalize all of them into one WebServiceDOS. However, there are often different ways to generalize. To continue the above example, Apache2 and Back attacks are against the apache web servers, while Crashiis is against the Microsoft IIS web server. To keep more information about the attacks, we may want to generalize Apache and Back into ApacheDOS, while generalize Crashiis and possibly other DOS attacks against the IIS web server into IISDOS. Nevertheless, this doesn't affect the attack strategy graphs extracted from correlated intrusion alerts as long as the constraints on the related alerts are satisfied. Automatic Generalization of Hyper-Alert Types It is timeconsuming and error-prone to manually generalize hyper-alert types. One way to partially automate this process is to use clustering techniques to identify the hyper-alert types that should be generalized into a common one. In our experiments, we use the bottom-up hierarchical clustering [18] to group hyper-alert types hierarchically on the basis of the similarity between them, which is derived from the similarity between the prerequisites and consequences of hyperalert types. The method used to compute the similarity is described below. To facilitate the computation of similarity between prerequisites of hyper-alert types, we convert each prerequisite into an expanded prerequisite set, which includes all the predicates that appear or are implied by the prerequisite. Similarly, we can get the expanded consequence set. Consider two sets of predicates, denoted S1 and S2 , respectively. We adopt the Jaccard similarity coefficient [17] to compute the similarity between S1 and S2 , denoted Sim(S1 , S2 ). That is, Sim(S1 , S2 ) = a+a , where a is the number of predib+c cates in both S1 and S2 , b is the number of predicates only in S1 , and c is the number of predicates only in S2 . Given two hyper-alert types T1 and T2 , the similarity between T1 and T2 , denoted Sim(T1 , T2 ), is then computed as Sim(T1 , T2 ) = Sim(XP1 , XP2 ) × wp + Sim(XC1 , XC2 ) × wc , where XP1 and XP2 are the expanded prerequisite sets of T1 and T2 , XC1 and XC2 are the expanded consequence sets of T1 and T2 , and wp and wc = 1 - wp are the weights for prerequisite and consequence, respectively. (In our experiments, we use wp = wc = 0.5 to give equal weight to both prerequisite and consequence of hyper-alert types.) We may then set a threshold t so that two hyper-alert types are grouped into the same cluster only if their similarity measure is greater than or equal to t. Remark Generalization of hyper-alert types is intended to hide unnecessary differences between different types of attacks. However, at the same time when it simplifies the attack strategies, it

may also hide critical details of attacks. Thus, generalization of hyper-alert types must be used with caution. A plausible way is to consider attack strategies learned at multiple generalization levels. It is also interesting to take advantage of the relationships between attack strategies at different generalization levels. However, this is out of the scope of this paper. We will consider this problem in our future work. A limitation of this method is that the attack strategies extracted from intrusion alerts heavily depend on the underlying IDSs and alert correlation system. In particular, if the IDSs miss a critical attack, or the alert correlation system leaves a critical step out of the corresponding attack scenario, the attack strategy may be split into multiple ones. Moreover, if the alert correlation system incorrectly places a false alert into an attack scenario, the quality of attack strategy will also degrade. Nevertheless, these problems exist even for manual intrusion analysis, and they have to be addressed by better intrusion detection and alert correlation techniques.

3. MEASURING SIMILARITY BETWEEN ATTACK STRATEGIES
In this section, we present a method to measure the similarity between attack strategy graphs based on error tolerant graph/subgraph isomorphism detection, which has been studied extensively in pattern recognition [3,21­24]. Since the attack strategy graphs are extracted from sequences of correlated alerts, the similarity between two attack strategy graphs are indeed the similarity between the original alert sequences in terms of their strategies. Such similarity measurement is a fundamental problem in intrusion analysis; it has potential applications in incident handling, computer and network forensics, and other security management areas. We are particularly interested in two problems. First, how similar are two attack strategies? Second, how likely is one attack strategy a part of another attack strategy? These two problems can be mapped naturally to error tolerant graph isomorphism and error tolerant subgraph isomorphism problems, respectively. To facilitate the later discussion, we give a brief overview of error tolerant graph/subgraph isomorphism. Further details can be found in the rich literature on graph/subgraph isomorphism [3, 21­24].

3.1 Error Tolerant Graph Isomorphism
In graph/subgraph isomorphism, a graph is a quadruple G = (N, E, T, C ), where N is the set of nodes, E is the set of edges, T is a mapping that assigns labels to the nodes, and C is a mapping that assigns labels to the edges. Given two graphs G1 = (N1 , E1 , T1 , C1 ) and G2 = (N2 , E2 , T2 , C2 ), a bijective function f is a graph isomorphism from G1 to G2 if ˇ for all n1  N1 , T1 (n1 ) = T2 (f (n1 )); ˇ for all e1 = (n1 , n1 )  E1 , there exists e2 = (f (n1 ), f (n1 ))  E2 such that C (e1 ) = C (e2 ), and for all e2 = (n2 , n2 )  E2 , there exists e1 = (f -1 (n2 ), f -1 (n2 ))  E1 such that C (e 2 ) = C (e 1 ). Given a graph G = (N, E, T, C ), a subgraph of G is a graph Gs = (Ns , Es , Ts , Cs ) such that (1) Ns  N , (2) Es = E (Ns × Ns ), (3) for all ns  Ns , Ts (ns ) = T (ns ), and (4) for all es  Es , Cs (es ) = C (es ). Given two graphs G1 = (N1 , E1 , T1 , C1 ) and G2 = (N2 , E2 , T2 , C2 ), an injective function f is a subgraph isomorphism from G1 to G2 , if there exists a subgraph G2s of G2 such that f is a graph isomorphism from G1 to G2s . As a further step beyond graph/subgraph isomorphism, error tolerant graph/subgraph isomorphism (which is also known as error correcting graph/subgraph isomorphism) is introduced to cope with noises or distortion in the input graphs. There are two approaches

for error tolerant graph/subgraph isomorphism: graph edit distance and maximal common graph. In this paper, we focus on graph edit distance to study the application of error tolerant graph/subgraph isomorphism in intrusion detection. The edit distance method assumes a set of edit operations (e.g., deletion, insertion and substitution of nodes and edges) as well as the costs of these operations, and defines the similarity of two graphs in terms of the least cost sequence of edit operations that transforms one graph into the other. We denote the edited graph after a sequence of edit operations  as (G). Consider two graphs G1 and G2 . The distance D(G1 , G2 ) from G1 to G2 w.r.t. graph isomorphism is the minimum sum of edit costs associated with a sequence of edit operations  on G1 that leads to a graph isomorphism from (G1 ) to G2 . Similarly, the distance Ds (G1 , G2 ) from G1 to G2 w.r.t. subgraph isomorphism is the minimum sum of edit costs associated with a sequence of edit operations  on G1 that leads to a subgraph isomorphism from (G1 ) to G2 . An error tolerant graph/subgraph isomorphism from G1 to G2 is a pair (, f ), where  is a sequence of edit operations on G1 , and f is a graph/subgraph isomorphism from (G1 ) to G2 . It is well known that subgraph isomorphism detection is an NPcomplete problem [15]. Error tolerant subgraph isomorphism detection, which involves subgraph isomorphism detection, is also in NP and generally harder than exact subgraph isomorphism detection [22]. Nevertheless, error tolerant subgraph isomorphism has been widely applied in image processing and pattern recognition [3,21­24]. In our application, all the attack strategy graphs we have encountered are small graphs with less than 10 nodes. We argue that it is very unlikely to have very large attack strategy graphs in practice. Thus, we believe error tolerant graph/subgraph isomorphism can be applied to measure the similarity between attack strategy graphs with reasonable response time. Indeed, we did not observe any noticeable delay in our experiments.

3.2 Working with Attack Strategy Graphs
To successfully use error tolerant graph/subgraph isomorphism detection techniques, we need to answer at least the following three questions. What are the edit operations on an attack strategy graph? What are reasonable edit costs of these edit operations? What is the right similarity measurement between attack strategy graphs? All the edit operations on a labeled graph are applicable to attack strategy graphs. Specifically, an edit operation on an attack strategy graph ASG = (N, E, T, C ) is one of the following: 1. Inserting a node n: $  n. This represents adding a stage into an attack strategy. This edit operation is only needed for error-tolerant graph isomorphism. 2. Deleting a node n: n  $. This represents removing a stage from an attack strategy. Note that this implies deleting all edges adjacent with n. 3. Substituting the hyper-alert type of a node n: T (n)  t, where t is a hyper-alert type. This represents changing the attack at one stage of the attack strategy. 4. Inserting an edge e = (n1 , n2 ): $  e, where n1 , n2  N . This represents adding dependency (i.e., prepare for relation) between two attack stages. 5. Deleting an edge e = (n1 , n2 ): e  $. This represents removing dependency (i.e., prepare for relation) between two attack stages. 6. Substituting the label of an edge e = (n1 , n2 ): C (e)  c, where c is a set of equality constraints. This represents changing the way in which two attack stages are related to each other. (Note that c is not necessarily a set of equality constraints for (T (n1 ), T (n2 )).)

These edit operations do not necessarily transform one attack strategy graph into another attack strategy graph. Indeed, a labeled graph must satisfy some constraints to be an attack strategy graph. For example, all the equality constraints in the label associated with (n1 , n2 ) must be valid equality constraints for (T (n1 ), T (n2 )). It is easy to see that the edit operations may violate some of these constraints. One may suggest that these constraints be enforced throughout the transformation of attack strategy graphs. As a benefit, this can be used to reduce the search space required for graph/subgraph isomorphism. However, this approach may not find the least expensive sequence of edit operations, and may even fail to find a transformation from one attack strategy graph to (the subgraph of) another. Indeed, editing distance is one way to measure the difference between attack strategy graphs; it is not necessary to require that all the intermediate edited graphs are attack strategy graph. As long as the final edited graph is isomorphic to an attack strategy graph, it is guaranteed to be an attack strategy graph. Thus, we do not require the intermediate graphs during graph transformation be attack strategy graphs. Assignment of edit costs to the edit operations is a critical step in error tolerant graph/subgraph isomorphism. The actual costs are highly dependent on the domain in which these techniques are applied. In our application, there are multiple reasonable ways to assign the edit costs. In the following, we attempt to give some constraints that the cost assignment must satisfy. In an attack strategy graph, a node represents a stage in an attack strategy, while an edge represents the causal relationship between two steps in the strategy. Obviously, changing the stages in an attack strategy affects the attack strategy significantly more than modifying the causal relationships between stages. Thus, the edit costs of node related operations should be significantly more expensive than those of the edge related operations. Inserting or deleting a node implies having one more or fewer step in the strategy, while substituting a node type implies to replace the attack in one step in the strategy. Thus, inserting or deleting a node has at least the same impact on the strategy as substituting the node type. Moreover, deleting and inserting a node are both manipulations of a stage; there is no reason to say one operation has more impact than the other. Therefore, they should have the same cost. Both inserting and deleting an edge changes the causal relationship between two attack stages, and they should have the same impact on the strategy. However, substituting the label of an edge is just to change the way in which two stages are related. Thus, it should have less cost than edge insertion and deletion. In summary, we can derive the following constraint in edit cost assignments. C ONSTRAINT 1. Costn$ = Cost$n  CostT (n)t >> Cost$e = Coste$  CostC (e)c . The labels in an attack strategy graph is indeed a set of equality constraints. Thus, labels are not entirely independent of each other. This further implies edit costs for edge label substitution should not be uniformly assigned. For example, substituting an edge label {A, B } for {A, C } should have less cost than substituting {A, B } for {C, D}. This observation leads to another constraint. C ONSTRAINT 2. Assume that the edit operation C (e)  c replaces C (e) = cold with cnew . The edit cost CostC (e)c should be smaller when cold and cnew have more equality constraints in common. Intuitively, Constraint 2 says the more equality constraints two labels have in common, the less cost the replacement operation should have. Here we give a simple way to accommodate Constraint 2. We assume there is a maximum edit cost for label substitution operation, denoted as M axCostC (e)c . The edit cost of

a label substitution is then CostC (e)c = M axCostC (e)c × |cold cnew | , where cold and cnew are the labels (i.e., sets of equal|cold cnew | ity constraints) before and after the operation. Error tolerant graph/subgraph isomorphism detection techniques can conveniently give a distance between two labeled graphs, which is measured in terms of edit cost. As we discussed earlier, we use these techniques to help answer two questions: (1) How similar are two sequences of attacks in terms of their attack strategy? (2) How likely does one sequence of attacks use a part of attack strategy in another sequence of attacks? In the following, we transform the edit distance measures into more direct similarity measures. Given an attack strategy graph ASG, we call the distance from ASG to an empty graph the reductive weight of ASG, denoted as Wr (ASG). Similarly, we call the distance from an empty graph to ASG the constructive weight of ASG, denoted Wc (ASG). D EFINITION 6. Given attack strategy graphs ASG1 and ASG2 , the similarity between ASG1 and ASG2 w.r.t. (attack) strategy is Sim(ASG2 ASG1 ) Sim(ASG1 , ASG2 ) = Sim(ASG1 ASG2 )+ , 2 D (ASGx ,ASGy ) where Sim(ASGx  ASGy ) = 1 - Wr (ASGx )+Wc (ASGy ) . D EFINITION 7. Given attack strategy graphs ASG1 and ASG2 , the similarity between ASG1 and ASG2 w.r.t. (attack) sub-strategy s (ASG1 ,ASG2 ) . is SimSub (ASG1 , ASG2 ) = 1 - WrD (ASG1 )+Wc (ASG2 ) We give a simple analysis of the impact of edit costs on the similarity measurements in the full version of this paper [30]. In summary, when the number of edges are not substantially more than the number of nodes, and the number of edge operations are not substantially more than the number of node operations, the similarity measure is mainly determined by the number of nodes and node operations rather than the edit costs.

4.1 Learning Attack Strategies
Our first goal is to evaluate the effectiveness of our approach on extracting the attack strategies. Figure 4 shows all of the attack strategy graphs extracted from the test data sets. The label inside each node is the node ID followed by the hyper-alert type of the node. The label of each edge describes the set of equality constraints for the hyper-alert types associated with the two end nodes. The attack strategy graphs we extracted from LLDOS 1.0 (inside part) are shown in Figure 4(a) and 4(b). (Note that Figure 4(a) has 7 nodes, which is much simplified compared with 44 nodes in the corresponding attack scenario reported in [29].) Based on the description of the data set [25], we know that both Figures 4(a) and 4(b) have captured most of the attack strategy. The missing parts are due to the attacks missed by the IDSs. In this part of experiments, we did not generalize variations of hyper-alert types. Thus, these graphs still have syntactic differences despite their common strategy. (Note that the "RPC sadmind UDP PING" alert reported by Snort is indeed the "Sadmind Amslverify Overflow" alert by RealSecure, and the "RPC portmap sadmind request UDP" alert by Snort is the "Sadmind Ping" alert by RealSecure.) Moreover, false alerts are also reflected in the attack strategy graphs. For example, the hyper-alert types "Email Almail Overflow" and "FTP Syst" in Figure 4(a) do not belong to the attack strategy, but they are included because of the false detection. The attack strategies extracted from LLDOS 2.0.2 are shown in Figures 4(c) and 4(d). Compared with the five phases of attack scenarios [25], it is easy to see that Figure 4(c) reveals most of the adversary's strategy. However, Figure 4(d) reveals two steps fewer than Figure 4(c). Our further investigation indicates that this is because one critical attack step, the buffer overflow attacks against sadmind service, was completely missed by Snort. Figures 4(e), 4(f), and 4(g) show the attack strategies extracted from the three sequences of attacks we performed. By comparing with the attacks, we can see that the stages as well as the constraints intrinsic to these attack strategies are mostly captured by these graphs. Though showing some potential, these experimental results also reveal a limitation of the attack strategy learning method: That is, our method depends on the underlying IDSs as well as the alert correlation method. If the hyper-alert correlation graphs do not reveal the entire attack strategy, or include false alerts, the attack strategy graphs generated by our method will not be perfect. Nevertheless, our technique is intended to automate the analysis process typically performed by human analysts, who may make the same mistake if no other information is used. More research is clearly needed to mitigate the impact of imperfect IDS and correlation. Another observation is that alerts from heterogeneous IDSs can help complete the attack strategies. For example, combining Figures 4(c) and 4(d), we know that an attacker may launch buffer overflow attacks against sadmind service and then use telnet to access the victim machine. Note that we do not give a quantitative performance evaluation of attack strategy extraction (i.e., the false positive and false negative of the extracted attack strategies). This is because such measures are determined by the underlying intrusion alert correlation algorithm. As long as correlation is performed correctly, our method can always extract the strategy reflected by the correlated alerts.

4.

EXPERIMENTS

We have performed a series of experiments to study the proposed techniques. In our experiments, we used the implementation of the correlation model, the NCSU Intrusion Alert Correlator [28], to correlate intrusion alerts. We also used GraphViz [2] to visualize graphs. In addition, we used GUB [21], A Toolkit for Graph Matching, to perform error tolerant graph/subgraph isomorphism detection and compute distances between attack strategy graphs. We used Snort [34] as our IDS sensor. Our test data sets include the 2000 DARPA intrusion detection scenario specific data sets [25]. The data sets contain two scenarios: LLDOS 1.0 and LLDOS 2.0.2. In LLDOS1.0, the sequence of attacks includes IPsweep, probes of sadmind services, breakins through sadmind exploits, installations of DDoS programs, and finally the DDoS attack. LLDOS 2.0.2 is similar to LLDOS 1.0; however, the attacks in LLDOS 2.0.2 are stealthier than those in LLDOS 1.0. In addition to the DARPA data sets, we also performed three sequences of attacks in an isolated network. In all these three attack sequences, the attacker started with nmap [14] scans of the victim. Then, in the first sequence, the attacker sent malformed urls [6] to the victim's Internet Information Services (IIS) to get a cmd.exe shell. In the second sequence, the attacker took advantage of the flaws of IP fragment reassembly on Windows 2000 [5] to launch a DoS attack. In the third sequence, the attacker launched a buffer overflow attack against the Internet Printing Protocol accessed via IIS 5.0 [4, 7]. We also used the alert sets provided along with the Intrusion Alert Correlator [28]. These alerts were generated by RealSecure Network Sensor [16] on the 2000 DARPA data sets, too. We label their alert sets with RealSecure, while label ours with Snort to distinguish between them.

4.2 Similarity Measurement
We performed experiments to measure the similarity between the previously extracted seven attack strategy graphs. To hide the unnecessary differences between alert types, we generalized similar alert types. We assume the edit costs for node operations are all 10, and the edit costs for the edge operations are all 1.

n1: FTP_Syst

{n1.DestIP=n2.DestIP}

n1: RPC portmap request sadmind
n2: Sadmind_Ping {n1.DestIP=n3.DestIP}

{n1.DestIP=n2.DestIP}
{n2.DestIP=n3.DestIP}

n2: RPC sadmind UDP PING
n3: Sadmind_Amslverify_Overflow n4: Email_Almail_Overflow

{n3.DestIP=n5.SrcIP}

{n4.DestIP=n5.SrcIP}

{n2.DestIP=n3.SrcIP}

{n3.DestIP=n6.SrcIP}

n5: Rsh

{n4.DestIP=n6.SrcIP}

n3: TELNET access

{n2.DestIP=n4.SrcIP}

{n5.SrcIP=n6.SrcIP}

{n3.SrcIP=n4.SrcIP}

n6: Mstream_Zombie

{n3.SrcIP=n5.SrcIP}

n4: RSERVICES rsh root

{}

{ n4.SrcIP=n5.SrcIP }

n7: Stream_DoS

n5: DDOS shaft client to handler

(a) LLDOS1.0 inside dataset (RealSecure)

(b) LLDOS1.0 inside dataset (Snort)

n1: Sadmind_Amslverify_Overflow

n2: Email_Almail_Overflow

{n1.DestIP=n2.DestIP}

{n2.DestIP=n3.DestIP}

{n1.DestIP=n2.SrcIP}

n3: FTP_Put

{n2.DestIP=n4.SrcIP}

{n3.DestIP=n2.SrcIP}

n4: Mstream_Zombie

n1: TELNET access

{}

{ n1.SrcIP=n2.SrcIP}

n5: Stream_DoS

n2: DDOS shaft client to handler

(c) LLDOS2.0.2 inside dataset (RealSecure)

(d) LLDOS2.0.2 inside dataset (Snort)

n1: ICMP PING NMAP

{n1.DestIP=n2.DestIP}

{n1.DestIP=n4.DestIP}

{n1.DestIP=n3.DestIP}

n2: SCAN namp fingerprint attempt

n4: SCAN namp XMAS

n3: SCAN namp TCP

{n2.DestIP=n6.DestIP}

{n4.DestIP=n6.DestIP}

{n2.DestIP=n5.DestIP}

{n4.DestIP=n5.DestIP}

{n3.DestIP=n6.DestIP}

{n3.DestIP=n5.DestIP}

n6: WEB-IIS cmd.exe access

n5: WEB-IIS unicode directory traversal attempt

{n6.DestIP=n7.SrcIP}

{n5.DestIP=n7.SrcIP}

n7: ATTACK RESPONSES http dir listing

(e) WEB-IIS unicode exploits (Snort)

n1: ICMP PING NMAP

n1: ICMP PING NMAP

{n1.DestIP=n2.DestIP}

{n1.DestIP=n2.DestIP}

{n1.DestIP=n3.DestIP}

{n1.DestIP=n4.DestIP}

n2: SCAN namp fingerprint attempt

n2: SCAN namp fingerprint attempt

n3: SCAN namp TCP

n4: SCAN namp XMAS

{n2.DestIP=n3.DestIP}

{n2.DestIP=n5.DestIP}

{n3.DestIP=n5.DestIP}

{n4.DestIP=n5.DestIP}

n3: (spp_frag2) Oversized fragment, probable Dos

n5: WEB-IIS ISAPI .printer access

(f) jolt2 DoS attack (Snort)

(g) WEB-IIS ISAPI .printer access (Snort)

Figure 4: Attack Strategy Graphs Extracted in Our Experiments Tables 1 and 2 show the similarity measurements between each pair of attack strategy graphs w.r.t. attack strategy and attack substrategy, respectively. Each subscript in the tables denotes the graph it represents. We notice that SimSub (Gi , Gj ) may not necessarily be equal to SimSub (Gj , Gi ). Table 1 indicates that Figure 4(a) is more similar to Figures 4(b), and 4(c) to the other graphs. In addition, Figure 4(g) is more similar to Figures 4(e) and 4(f) than the other graphs. Based on the description of these attack sequences, we can see these similarity measures conform to human perceptions.

Table 1: The similarity w.r.t. attack strategy between attack strategy graphs in Figure 4
G4(a) G4(b) G4(c) G4(d) G4(e) G4(f ) G4(g) G4(a) G4(b) G4(c) G4(d) G4(e) G4(f ) G4(g) / 0.72 0.73 0.21 0.29 0.31 0.25 0.72 / 0.66 0.55 0.25 0.25 0.29 0.73 0.66 / 0.40 0.34 0.38 0.30 0.21 0.55 0.40 / 0.21 0.40 0.38 0.29 0.25 0.34 0.21 / 0.48 0.74 0.31 0.25 0.38 0.40 0.48 / 0.61 0.25 0.29 0.30 0.38 0.74 0.61 /

Table 2: The similarity w.r.t. attack sub-strategy between attack strategy graphs in Figure 4
G4(a) G4(b) G4(c) G4(d) G4(e) G4(f ) G4(g) G4(a) G4(b) G4(c) G4(d) G4(e) G4(f ) G4(g) / 0.72 0.66 0.31 0.53 0.31 0.43 0.89 / 0.67 0.55 0.61 0.38 0.51 0.90 0.68 / 0.40 0.61 0.38 0.52 0.89 1.00 0.86 / 0.79 0.60 0.73 0.51 0.58 0.58 0.21 / 0.48 0.26 0.72 0.65 0.65 0.40 0.91 / 0.89 0.59 0.51 0.48 0.27 0.93 0.61 /

We then perform the following steps, trying to identify attacks possibly missed in LLDOS 2.0.2. We pick node n1 in Figure 4(d), and find its corresponding node n3 in Figure 4(b), which is mapped to n1 by the subgraph isomorphism. It is easy to see that in Figure 4(b), the precedent set of n3 is {n1 n2}, and n1 has the type "RPC portmap sadmind request UDP". We then go back to LLDOS 2.0.2 alerts, and find "RPC portmap sadmind request UDP" alerts before "TELNET ACCESS". By comparing the precedent set of n1 in Figure 4(d) and the precedent set of n3 in Figure 4(b), we suspect that "RPC sadmind UDP PING" (which corresponds to node n2 in Figure 4(b)) has been missed in LLDOS 2.0.2. If we add such an alert, we may correlate it with "RPC portmap sadmind request UDP" and further with "TELNET access" in Figure 4(d). Indeed, "RPC sadmind UDP PING" is the buffer overflow attack missed by Snort in LLDOS 2.0.2. The later part of example 5 is very similar to the abductive correlation proposed in [9]. The additional feature provided by the similarity measurement is the guidelines about what attacks may be missed. In this sense, the similarity measurement is complementary to the abductive correlation. Moreover, these examples are provided to demonstrate the potential of identifying missed attacks through measuring similarity of attack sequences. It is also possible that the attacker didn't launch those attacks. Additional research is necessary to improve the performance and reduce false identification rate.

Table 2 shows the similarity between attack strategy graphs w.r.t. attack sub-strategy. We can see that Figures 4(b), 4(c), and 4(d) are very similar to a sub-strategy of Figure 4(a). In addition, Figure 4(d) is exactly a sub-strategy of Figure 4(b). Similarly, Figures 4(g) and 4(f) are both similar to sub-strategies of Figure 4(e), and Figure 4(f) is also similar to a sub-strategy of Figure 4(g). Comparing these measure values with these attack sequences, we can see these measures also conform to human perceptions. The experiments also reveal several remaining problems. First, the similarity measures make sense in terms of their relative values. However, we still do not understand what a specific similarity measure represents. Second, false alerts generated by IDSs have a negative impact on the measurement. It certainly requires further research to address these issues.

5. RELATED WORK
Our work in this paper is closely related to the recent results in intrusion alert correlation. In particular, our attack strategy model can be considered as an extension to [9] and [29]. In addition to correlating alerts together based on their relationships, we further extract the attack strategy used in the attacks, and use them to measure the similarity between sequences of alerts. There are other alert correlation techniques. The techniques in [8, 11, 36, 38] correlate alerts on the basis of the similarities between the alert attributes. The Tivoli approach correlates alerts based on the observation that some alerts usually occur in sequence [12]. M2D2 correlates alerts by fusing information from multiple sources besides intrusion alerts, such as the characteristics of the monitored systems and the vulnerability information [26], thus having a potential to result in better results than those simply looking at intrusion alerts. The mission-impact-based approach correlates alerts raised by INFOSEC devices such as IDS and firewalls with the importance of system assets [32]. The alert clustering techniques in [20] use conceptual clustering and generalization hierarchy to aggregate alerts into clusters. Alert correlation may also be performed by matching attack scenarios specified by attack languages. Examples of such languages include STATL [13], LAMBDA [10], and JIGSAW [37]. We consider these techniques as complementary to ours. Our approach is also closely related to techniques for static vulnerability analysis (e.g., [1, 19, 33, 35]). In particular, the methods in [1, 35] also use a model of exploits (possible attacks) in terms of their pre-conditions (prerequisites) and post-conditions (consequences). Our approach complements static vulnerability analysis methods by providing the capability of examining the actual execution of attack strategies in different details (e.g., an attacker tries different variations of the same attack), and thus gives human users more information to respond to attacks. Our approach to similarity measurement of attack strategies is based on error-tolerant graph/subgraph isomorphism [21­24]). By using the distance between labeled graphs and the constraints in

4.3 Identification of Missed Detections
Our last set of experiments is intended to study the possibility to apply the similarity measurement method to identify attacks missed by IDSs. For the sake of presentation, we first introduce two terms: precedent set and successive set. Intuitively, the precedent set of a node n in an attack strategy graph is the set of nodes from which there are paths to n, while the successive set of n is the set of nodes to which n has a path. In the following, we show two examples we encountered in our experiments. E XAMPLE 4. The attack strategy graph in Figure 4(c) has no probing phase, but Figure 4(a) does. The similarity measurement SimSub (G4(c) , G4(a) ) = 0.90 and Sim(G4(c) , G4(a) ) = 0.73 indicate that these two strategies are very similar and it is very likely that Figure 4(c) is a sub-strategy of Figure 4(a). Thus, it is possible that some probe attacks are missed by the IDS when the IDS detected the attacks corresponding to Figure 4(c). Indeed, this is exactly what happened in LLDOS 2.0.2. The adversary uses some stealthy attacks (i.e., HINFO query to the DNS server) to get the information about the victim hosts. E XAMPLE 5. Consider Figures 4(d) and 4(b). We have SimSub (G4(d) , G4(b) ) = 1.0. Thus, G4(d) is exactly a sub-strategy of G4(b) . By checking the LLDOS2.0.2 alerts reported by Snort, we know that there are also "RPC portmap sadmind request UDP" alerts as in Figure 4(b). However, since Snort did not detect the later buffer overflow attack, these "RPC portmap sadmind request UDP" alerts aren't correlated with the later alerts.

attack strategies, we derive quantitative measurements for the similarity between attack strategies.

6.

CONCLUSION AND FUTURE WORK

In this paper, we developed techniques to extract attack strategies from correlated intrusion alerts. Our contributions include a model to represent, and algorithms to extract, attack strategies from correlated intrusion alerts. To accommodate variations in attacks that are not intrinsic to attack strategies, we proposed to generalize different types of intrusion alerts to hide the unnecessary difference between them. We also developed techniques to measure the similarity between attack sequences based on their strategies. Our experimental results have demonstrated the potential of these techniques. Several research directions are worth investigating, including approaches to taking advantage of relationships between attack strategies extracted at different generalization levels, techniques to reason about attacks possibly missed by IDSs, and system support for learning and using attack strategies.

7.

REFERENCES

[1] P. Ammann, D. Wijesekera, and S. Kaushik. Scalable, graph-based network vulnerability analysis. In Proc. of the 9th ACM Conf. on Comp. and Comm. Security, 2002. [2] AT & T Research Labs. Graphviz - open source graph layout and drawing software. http://www.research.att. com/sw/tools/graphviz/. [3] H. Bunke and K. Shearer. A graph distance metric based on the maximal common subgraph. Pattern Recognition Letters, 19(3-4):255­259, 1998. [4] CERT Coordination Center. Cert advisory CA-2001-10 buffer overflow vulnerability in microsoft IIS 5.0. [5] Microsoft Corporation. Microsoft security bulletin (ms00-029). 2000. [6] Microsoft Corporation. Microsoft security bulletin (ms00-078). 2000. [7] Microsoft Corporation. Microsoft security bulletin (ms01-023). 2001. [8] F. Cuppens. Managing alerts in a multi-intrusion detection environment. In Proc. of the 17th Annual Computer Security Applications Conf., December 2001. [9] F. Cuppens and A. Miege. Alert correlation in a cooperative intrusion detection framework. In Proc. of the 2002 IEEE Symp. on Security and Privacy, May 2002. [10] F. Cuppens and R. Ortalo. LAMBDA: A language to model a database for detection of attacks. In Proc. of RAID 2000, pages 197­216, 2000. [11] O. Dain and R.K. Cunningham. Building scenarios from a heterogeneous alert stream. In Proc. of the 2001 IEEE Workshop on Info. Assurance and Security, 2001. [12] H. Debar and A. Wespi. Aggregation and correlation of intrusion-detection alerts. In Proc. of RAID 2001, pages 85 ­ 103, 2001. [13] S.T. Eckmann, G. Vigna, and R.A. Kemmerer. STATL: An Attack Language for State-based Intrusion Detection. J. of Computer Security, 10(1/2):71­104, 2002. [14] Fyodor. Nmap free security scanner. http://www.insecure.org/nmap, 2003. [15] M. R. Gary and D. S. Johnson. Computers and Intractability: A Guide to the Theory of NP-Completeness. 1979. [16] Internet Security Systems. RealSecure intrusion detection system. http://www.iss.net.

[17] D. A. Jackson, K. M. Somers, and H. H. Harvey. Similarity coefficients: Measures of co-occurence and association or simply measures of occurrence? The American Naturalist, 133(3):436­453, March 1989. [18] A.K. Jain and R.C. Dubes. Algorithms for Clustering Data. Prentice Hall, 1988. [19] S. Jha, O. Sheyner, and J.M. Wing. Two formal analyses of attack graphs. In Proc. of the 15th Computer Security Foundation Workshop, June 2002. [20] K. Julisch. Mining alarm clusters to improve alarm handling efficiency. In Proc. of the 17th Annual Computer Security Applications Conf, pages 12­21, December 2001. [21] B. T. Messmer. Efficient Graph Matching Algorithms for Preprocessed Model Graphs. PhD thesis, University of Bern, Switzerland, November 1995. [22] B. T. Messmer and H. Bunke. A new algorithm for error-tolerant subgraph isomorphism detection. IEEE Trans. on Pattern Analysis and Machine Intelligence, 20(5):493­504, 1998. [23] B. T. Messmer and H. Bunke. Efficient subgraph isomorphism detection: A decomposition approach. IEEE Trans. on Knowl. and Data Engineer., 12(2):307­323, 2000. [24] B.T. Messmer and H. Bunke. A decision tree approach to graph and subgraph isomorphism detection. Pattern Recognition, 32(12):1979­1998, 1999. [25] MIT Lincoln Lab. 2000 DARPA intrusion detection scenario specific datasets. http://www.ll.mit.edu/IST/ ideval/data/2000/2000_data_index.html. [26] B. Morin, L. M´ e, H. Debar, and M. Ducass´ e. M2D2: A formal data model for IDS alert correlation. In Proc. of RAID 2002, 2002. [27] N. J. Nilsson. Principles of Artificial Intelligence. 1980. [28] P. Ning and Y. Cui. Intrusion alert correlator (version 0.2). http://discovery.csc.ncsu.edu/software/ correlator/ver0.2/iac.html, 2002. [29] P. Ning, Y. Cui, and D. S Reeves. Constructing attack scenarios through correlation of intrusion alerts. In Proc. of the 9th ACM Conf. on Comp. and Comm. Security, 2002. [30] P. Ning and D. Xu. Learning attack stratagies from intrusion alerts. TR-2003-16, Dept. of Comp. Sci., NCSU, 2003. [31] Packet storm. http://packetstormsecurity.nl. Accessed on April 30, 2003. [32] P.A. Porras, M.W. Fong, and A. Valdes. A mission impact based approach to INFOSEC alarm correlation. In Proc. of RAID 2002, pages 95­114, 2002. [33] C.R. Ramakrishnan and R. Sekar. Model-based analysis of configuration vulnerabilities. J. of Computer Security, 10(1/2):189­209, 2002. [34] M. Roesch. Snort - lightweight intrusion detection for networks. In Proc. of the 1999 USENIX LISA Conf., 1999. [35] O. Sheyner, J. Haines, S. Jha, R. Lippmann, and J.M. Wing. Automated generation and analysis of attack graphs. In Proc. of IEEE Symp. on Security and Privacy, May 2002. [36] S. Staniford, J.A. Hoagland, and J.M. McAlerney. Practical automated detection of stealthy portscans. J. of Computer Security, 10(1/2):105­136, 2002. [37] S. Templeton and K. Levitt. A requires/provides model for computer attacks. In Proc. of New Security Paradigms Workshop, pages 31 ­ 38. September 2000. [38] A. Valdes and K. Skinner. Probabilistic alert correlation. In Proc. of RAID 2001, pages 54­68, 2001.

