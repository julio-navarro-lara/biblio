Managing Alerts in a Multi-Intrusion Detection Environment
Frédéric Cuppens ONERA Toulouse 2 av. E. Belin, BP 4025, 31055 TOULOUSE CEDEX, France cuppens@cert.fr
Abstract
There are several approaches for intrusion detection but none of them is fully satisfactory. They generally generate too many false positives and the alerts are too elementary and not enough accurate to be directly managed by a security administrator. A promising approach is to develop a cooperation module to analyze alerts and to generate more global and synthetic alerts. This paper presents the work we did in this context within the MIRADOR project. We suggest specifications for three functions: alert base management, alert clustering and alert merging. The approach is compliant with the IDMEF format currently being defined at the IETF. Keywords: IDS, IDMEF, DTD, cooperative intrusion detection, alert clustering, alert merging. the possibility to combine IDS that work differently: a first IDS can based on the behavioral approach (see [19] for instance), a second one on signature analysis (see [17] for instance), a third one on scenarios recognition (see [14] for instance) and still another one on abnormal exchange detection [2]. All these approaches are complementary and cooperation should lead to derive a global diagnosis more pertinent than individual diagnoses brought out separately by each IDS. A first attempt to design an IDS with cooperative functionality between different approaches, namely the behavioral and signature analysis approaches, was suggested in the IDES project [13] and then refined in the EMERALD project [17]. Recent developments in this context suggest using Bayesian networks [20] and probabilistic alert correlation [21]. Another proposal is the Tivoli Enterprise Console suggested by [8] The main objective of IDS cooperation is to correlate alerts in order to generate more global alerts and discard false alerts. The objective of this paper is to present the work we have done in order to prepare alert correlation. This is a part of an ongoing project, called Mirador, sponsored by the French DGA/CASSI (Délégation Générale de l'Armement). The context of this work is an intrusion detection environment with several IDS that generate alerts when abnormal events occur. In order to reach the correlation objective, we shall specify the three following functions: - Alert management function. Alert messages generated by different IDS are stored and managed in a relational database. - Alert clustering function. Alerts mapping to the same occurrence of an attack are recognized and gathered into the same "cluster". - Alert merging function. A global alert is generated for each cluster identified by the clustering function. In this paper, we shall focus on these three functions. The correlation function is not addressed and will be presented in a forthcoming paper. However, the mere outline of this function is presented in the conclusion section. Section 2 presents the main principles of the approach suggested in this paper and specifies the kind of implementation we choose for the cooperation module. Then, section 3 describes how we manage alert messages that come from different intrusion detection systems.

1.

Introduction

Many head network administrators put their trust in firewalls to maintain a secure environment, which can fall unfortunately short. Some rely on the system administrator's ability to lock those servers that are essential. Others choose to predefine security policies and procedures, but ignore the gaps left by evolving technologies. Few security agents have the insight to associate security policies with technology-based security solutions. For most enterprises and organizations, a combination of these approaches can address a fairly comprehensive set of vulnerabilities. However, they still miss some facets of network security such as event correlation and secure audit trails for forensic analysis. This is where intrusion-detection systems (IDS) show their value [1]. The approach is appealing: a set of distributed systems that spot, identify and alert security administrators about active attacks in real time [16]. Unfortunately, classical intrusion detection approaches, like signature analysis [10] generally detect too elementary intrusions. In the case of a network, for instance, many intrusion detection systems (IDS) can be installed. Each one is concerned by some part of the network. It is then necessary to make them cooperate in order to get a global vision of the intrusion. Another point that vindicates this cooperative approach is

Section 4 specifies the alert clustering function. Section 5 shows how we use different clusters built up by the clustering function to generate global alerts. Section 6 presents the experiments we have done to validating our approach. Finally, section 7 concludes and sketches the correlation function.
Alerts Alert Clustering Alert Clusters

2.

Principles of the approach

Figure 1 presents the main principles we suggest to develop a cooperation module for intrusion detection. There are five main functions in this module.

Alert Merging

Global alerts

Alert base management function

Alert Correlation

Candidate Plans

Intention Recognition Global diagnosis

IDS

IDS

IDS

Reaction

Figure 1: General Schema of a cooperation module The alert base management function receives the alerts generated by different IDS and stores them for further analysis by the cooperation module. We shall assume that all these alerts are compliant with the Intrusion Detection Message Exchange Format (IDMEF) [4]. The purpose of the IDMEF is to define common data formats and exchange procedures for sharing information of interest to intrusion detection and response systems, and those which may need to interact with them. IDMEF is intended to be a standard data format that intrusion detection systems are supposed to use to report alerts about events that they consider suspicious. The most obvious place to implement the IDMEF is in the data channel between an intrusion detection analyzer and the manager to which it sends alarms. A Document Type Definition (DTD) has been proposed to describe IDMEF data format through XML documents. This is the representation we shall consider in the remainder of this paper. The approach we suggest to implement the alert base management function is then to convert the IDMEF messages into a set of tuples and to store them into a relational database. The clustering function can then have an access to this database and generates clusters of alerts. A cluster of alerts is a set of alerts that correspond to the same occurrence of an attack. These alerts are generated by the same IDS or by different IDS. As suggested in section 4, a relation of similarity connects alerts belonging to the same cluster. Each cluster is then sent to the alert merging function. The purpose of this function is to create a new alert that is representative of the information contained in the various alerts belonging to this cluster. The correlation function only deals with alerts generated by the merging function1. The principle of the correlation function is to consider that the intruder wants to achieve a malicious objective but he cannot generally get his way by only performing a single attack. Instead, he usually performs several attacks that correspond to steps of a more global intrusion plan that enables him to achieve his malicious objective. Classical IDS only detect elementary attacks that correspond to the steps of this intrusion plan. The objective of the correlation function is thus to correlate alerts in order to recognize the intrusion plan that is currently executed by the intruder. The result of this function is a set of candidate plans that correspond to the intrusion under execution by the intruder. However, the final objective of the intruder is

1 However, notice that no alert is lost, because a cluster might contain only one alert. In this case, the global alert generated by the merging function is quite similar to the alert belonging to the cluster.

perhaps not achieved yet. This is the purpose of the intention recognition function to extrapolate these candidate plans in order to anticipate the intruder intentions. This function should provide a global diagnosis of the past (what the intruder has performed up to now), the present (what the intruder has obtained and what is the current security state of the system targeted by the intruder) and the future (how the intruder will go on). The result of this function is to be used by the reaction function to help the system administrator to choose the best counter measure to be launched to prevent the malicious actions performed by the intruder. As mentioned in the introduction, we shall only suggest a specification for the alert base management, clustering and merging functions. The correlation and intention recognition functions are not presented. They are under development and the approach we suggest for these functions are briefly sketched in the conclusion of this paper.

<!ELEMENT Alert (CreateTime, DetectTime?, AnalyzerTime?, Analyzer, Classification+, Source*, Target*, ToolAlert?,OverflowAlert?,CorrelationAlert?, AdditionalData? ) > <!ENTITY % ext.attlist.Alert ""> <!ATTLIST Alert version CDATA #FIXED '1' ident CDATA #REQUIRED impact CDATA 'unknown' %attlist.global; %ext.attlist.Alert; >

The application of a set of straightforward rewriting rules and the three predicates defined above, leads to the following set of Prolog facts:
entity(alert). attribute(alert,version,"CDATA","#FIXED '1'"). attribute(alert,ident,"CDATA","#REQUIRED"). attribute(alert,impact,"CDATA","unknown"). element(alert,createtime,"1-1"). element(alert,detecttime,"0-1"). element(alert,analyzertime,"0-1"). element(alert,analyzer,"1-1"). element(alert,classification,"1-n"). element(alert,source,"0-n"). element(alert,target,"0-n"). element(alert,toolalert,"0-1"). element(alert,overflowalert,"0-1"). element(alert,correlationalert,"0-1"). element(alert,additionaldata,"0-1").

3.

Managing Alerts in a Database

We choose to manage alert messages in a relational database. This database is currently implemented using Prolog. The problem of how transferring our work to a real relational database is further discussed in [6]. In this section, we describe the transformation process of an alert message specified in XML format to a set of tuples. So, we start by describing how a database schema is derived from the DTD and subsequently, we show how to generate, from a given alert message, a set of tuples that are instances of this schema.

3.1.

Database Schema Generation

The schema generation process takes place in two steps. We first analyze the DTD in order to generate a set of Prolog facts corresponding to this DTD. To do so, we introduce three predicates: - entity (entity_name): entity_name is the name of an entity described in the DTD. - attribute (entity_name, attribute_name, attribute_type, mark): attribute_name is an attribute of entity_name and it has the type attribute_type. The mark parameter can have the value "#required", "#implied" or "#fixed". In all other cases, it is assigned a default value. - element (entity_name, element_name, card): element_name is a component of entity_name and card is the cardinality of the relationship that links entity_name and element_name. card  {0-1, 1-1, 0-n, 1-n} that respectively corresponds to the flags {?, no flag, *, +}. To see how to proceed to generate Prolog facts, let us have the following portion of the DTD (see [4]):

Then, as a second step, we analyze these facts to convert them into a set of relations according to the following agreements: - Each entity appearing in a fact becomes a relation. - Each entity attribute becomes an attribute of the corresponding relation. - Each entity has an identifier. If it is not the case, it is advisable to generate one. For instance, createtimeid has been generated to be the identifier of the entity createtime. This attribute is used as a key for the relation createtime and as a foreign key for the relation alert to allow createtime to be referenced. - Notice that we also generate an identifier alertid to uniquely identify an alert. This identifier is distinct from the attribute ident used in the IDMEF format (see the portion of the DTD above). This is because ident locally identifies an alert within a given IDS whereas alertid uniquely identifies every alert received by the cooperation module. - In the case of an element, if its cardinality belongs to {0-1,1-1}, a new attribute is inserted in the corresponding relation. If its cardinality belongs to{0-n,1-n}, a new relation, called a relationship relation, is created. For instance, we add createtimeid and analyzerid as attributes of the relation alert. These attributes are used as foreign keys to respectively reference the relations createtime and analyzer. In another hand, we create

a new relation alertsource to represent the relationship between alert and source. alertid and sourceid are its attributes. For the sake of information, the transformation process applied to the IDMEF DTD produces 28 relations.

3.2.

Alert Insertion

Once the database schema is generated, each XML alert message is analyzed and converted into a set of tuples that are instances of the relational database schema. For this purpose, each XML message is analyzed to generate relation instances (for relations seen in section 3.1) with respect to the following points: - Entity identifier attributes are integers autoincremented when a new relation instance is inserted. - Default values (unknown value) are generated for those attributes that are not described in the alert message in hand. - Instances of relationship relations are created so that relationships between entities can be managed. - Redundancy must be avoided to make easier correlation tasks. Thus, we check that some entity has not already been created with the same attribute values. Last point is important. As a matter of fact, the number of tuples to be inserted when a new alert message is transmitted might be high when the system is initialized but this number goes lower when the system proceeds. For instance, the number of possible targets is finite so that it will not be necessary to create new tuples for the corresponding target relation when the alert base management function will know all these targets.

4.

Alert Clustering

In this section, we describe the first function of the cooperation module, that is the clustering function of alerts generated by various IDS. This function is used to identify and cluster those alerts sent by different IDS that match the same attack occurrence.

4.1.

Similarity Relation

First of all, we recall that alerts generated by various IDS are stored in a relational database. When an IDS generates a new alert, the clustering function determines those existent alerts in the database that can be "linked" to this new alert. Thus, the point is to define a similarity relation between two alert messages. Intuitively, a similarity relation defines in which cases two alerts are considered to be close enough to be clustered. This problem was addressed by Valdes and Skinner [21].

They suggest using a probabilistic approach where a similarity function is defined for each attribute and the overall similarity is obtained by combining basic similarity functions using an expectation of similarity. In our approach, we decided not to use a probabilistic approach. Instead, we suggest an "expert system" approach in which each similarity requirement is specified using expert rules. As the reader will notice, the results we obtained using this approach are satisfactory (see section 6 for the experiments). Figure 2 gives the main principles we suggest to specifying the clustering function. According to figure 2, we first introduce the following predicate to model the similarity relation: sim_alert(Alertid1, Alertid2), to say that alerts respectively identified by Alertid1 and Alertid2 are similar (so they can be clustered). Sim_alert is "built" from more elementary similarity relations existing between various entities that form the alert message (for instance, the entity type "Detecttime" that indicates alert occurrence date or the entity type "Classification" that describes attacks in alert messages). So, we introduce the following predicate to model this elementary similarity relation: sim_entity(Type_entity,Entity1,Entity2) This predicate says that some similarity relation links Entity1 and Entity2 having the entity type Type_entity. Defining a similarity relation between two entities depends on the examined entity type. Therefore, clustering function specification have to go through specification of similarity relation between various entities that make up an alert, in particular Detecttime, Source, Target and Classification entities. Since we choose to specify an alert message as a set of tuples in a relational database, defining sim_entity consists in comparing tuple instances of the relation corresponding to Type_entity. So, we introduce the following predicate: sim_instance(Name_relation,Tuple1,Tuple2) This predicate indicates that Tuple1 and Tuple2 that are instances of Name_relation are similar. Generally, defining this predicate goes through defining a similarity relation between Tuple1 and Tuple2 attributes. Once again, we need to introduce the following predicate: sim_attribute(Name_relation,Att,Val1,Val2) This predicate indicates that attribute Att's values, Val1 and Val2, of Name_relation are similar. Finally, we saw in section 3.2 that we had sometimes to create instances of relationship relations to properly manage relationships between entities. For instance, alertsource depicts a relationship that links alert and source entities. Therefore, to define Alert1 and Alert2 similarity relation, we have to introduce in which case alertsource relationship is similar for both Alert1 and Alert2. This leads us to introduce the following predicate:

Similar alerts

Similar Entities

Similar instances

Instance similarity expert rule

Similar attributes

Attribute values similarity expert rule

Similar relationships

Figure 2: Clustering function general principles sim_relationship(Name_relationship,Entity1,Entity2) We implicitly assume that Entity1 and Entity2 in the above predicate are of the same type and we consider them as attribute values in the relationship Name_relationship. For instance, we can use sim_relationship(alertsource,Alert1,Alert2) to define in which case the sources of Alert1 and Alert2 are similar. Notice that we consider by default that two entities, Entity1 and Entity2 have similar Name_relationship relation if there exists at least two entities E1 and E2 linked respectively by a relationship to Entity1 and Entity2 such that E1 and E2 are similar. For instance, if Entity1 and Entity2 are two alert identifiers, if Name_relationship is the alertsource relation then Relation2 will be equal to the source relation. E1 will match some alert source of Entity1 and E2 will match some alert source of Entity2. In this case, the above relationship similarity rule will conclude that sim_relationship(alertsource,Entity1,Entity2) when there exists a source E1 of Entity1 and a source E2 of Entity2 such that sim_entity(source,E1,E2). Notice that we adopt a generic approach to define the clustering function. In particular, it must be easily adaptable when the DTD describing alert messages evolves. Hence, if a new entity type is introduced in the DTD, it is sufficient to use sim_entity to specify in which case two entity instances are similar. Likewise, if a new attribute describing an entity is introduced in the DTD, it is sufficient to specify, using the predicate sim_attribute, in which case two values of this attribute are similar. to specify in which case instances of the following entities are similar: classification, time, source, target. 4.2.1. Classification similarity

In the IDMEF format, the attack type description is provided in the classification field. Notice first that the classification used to identify an attack may differ from one IDS to another. This might complicate the clustering task. To solve this problem, we assume that there exists a relation in the database of the following format: test_IDS(attack_name, IDS_name, generated_name) This relation specifies that for a given standard attack name attack_name (see for instance [15]) and a given IDS identified by IDS_name, what is the generated_name that appears in the alert message emitted by this IDS. The value "unknown" is used conventionally when this IDS does not generate an alert when the attack occurs (false negative). Notice that if the IDS generates several alerts for a given attack_name, several tuples for the same pair (attack_name, IDS_name) will appear in the IDS_test table. In our approach, an expert rule then specifies in which case two entities of type classification are similar. This rule says that the attack detected by Alert1 is similar to the attack detected by Alert2 if there is a common attack whose name is Attack_name that is detected by the IDS IDS_name1 as Generated_name1 and by the IDS IDS_name2 as Generated_name2. 4.2.2. Time similarity

4.2.

Similarity expert rules

As mentioned in figure 2, our approach to be effective requires specifying some similarity expert rules. These rules are domain specific and it is necessary to analyze alerts generated by several IDS to properly define these rules. In our implementation, we have defined expert rules

Three temporal attributes can be associated to an alert in the DTD defined by the IDMEF: (1) detecttime: the attack occurs at this time, (2) createtime: the attack is detected at this time and (3) analyzertime: the alert is emitted at this time by the IDS. Createtime and analyzertime are fully dependant on the characteristics of the IDS. These two attributes do not intervene in the similarity function. This means that two

alerts might be considered similar even though their createtime and analyzertime are completely different. We actually only use the detecttime attribute in the similarity function. The approach is to define a delay: two alerts will not be considered similar if the temporal difference between their detecttime exceeds this delay. Properly calibrating this delay is crucial to obtain good clustering results. This problem is further discussed during the experiment (see section 6). 4.2.3. Source and target similarity

In the IDMEF format, the structures of attributes source and target are similar. They might be both described by a node, a user, a process and a service. A first role of the similarity function is to create correspondences between the source and target description of the alerts to be compared. For instance and as noticed in [8], a node might be identified by its IP address (typically by a network-based IDS) or by its host name (typically by a host-based IDS). Similarly, some IDS will provide service names and others, port numbers. To solve these problems, the similarity function uses correspondence tables: (1) between host names and IP addresses and (2) between services and port numbers. The second role of the similarity function is to define in which cases (1) two sources might be considered similar and (2) two targets might be considered similar. A first approach would be to specify that a similarity exists if both their nodes, users, services and processes are similar. This approach by "default" generally leads to two strong conditions. For some attacks (a tcp-scan for example), it is sufficient to specify that two targets are similar if the target nodes are similar. And for most network attacks, we shall simply compare the nodes and services. This means that we need to specify expert rules to properly tune the similarity function between sources and targets (see section 6 for further details).

5.

Merging Alerts and Conflict Resolution

Alert clustering function results in building groups of alerts that we call "clusters". We introduce the following predicate to specify alert cluster: cluster_alert(clusterid,alertid) This predicate means that an alert identified by alertid belongs to a cluster identified by clusterid. The merging function is used to generate for each cluster that has been identified by the clustering function, a global alert. This is represented by the following predicate: cluster_global_alert(clusterid,alertid) This predicate says that an alert identified by alertid is the global alert associated to the cluster identified by clusterid. Generating this global alert consists in "gathering" most of the information specified in the alerts. This is

represented by expert rules specifying how the global alert tuples are derived from tuples describing the alerts belonging to the cluster. The general process to derive a global alert for each cluster is the following. Let us assume that a new alert alerti is inserted. There are two possibilities. (1) If there is no alert similar to alerti, then a new cluster is created and a global alert is derived for this cluster. Of course, this global alert will be quite similar to alerti. (2) If alerti might be inserted in an already existing cluster, then the global alert associated with this cluster is updated by merging alerti with the global alert of this cluster. Notice that inserting a new alert may lead to merge several existing clusters into one unique cluster. For instance, let us consider a situation where there are two clusters cluster1 and cluster2 and let us assume that alert1 and alert2 are the global alerts associated with these clusters. Let us now consider a new alert alert3 and let us assume that this alert might be inserted in both cluster1 and cluster2. Then, in this case, both alert1 and alert2 are updated with alert3. If after this update, alert1 and alert2 are similar, then cluster1 and cluster2 are merged into one cluster and the global alert associated with this cluster is the result of merging alert1 and alert2. In the remainder of this section, we shall present how to derive the temporal, source, target and classification attributes of the global alert from the ones associated to the alerts belonging to the cluster to be merged. But, before doing so, notice that several points arise. First, various IDS can generate some alert; this can lead to conflict if an IDS doesn't detect an attack whereas it has the ability to do so. In this case, we shall say that this IDS is non-reactive towards the cluster related to this attack. So, if there exists non-reactive IDS, we say that there is a global conflict. We choose to assign likelihood coefficient to each cluster. This coefficient is inversely proportional to the number of non-reactive IDS: the higher the number, the lower the coefficient. However, we deliberately keep the cluster even if the likelihood is very low because other functions (in particular, the correlation one) can possibly update it. This coefficient is given by the following formula: nb_IDS_cluster 100 / (nb_IDS_cluster + nb_ non_reactive_IDS) where nb_IDS_cluster is the number of reactive IDS towards a given cluster and nb_non_reactive_IDS is the number of non-reactive IDS towards the same cluster. Notice that this formula can be slightly refined if we assign likelihood coefficients to alerts belonging to the cluster and if each IDS carries a weight. The likelihood coefficient of the global alert is specified as an additionaldata attribute of this alert. Second, new alerts can be added to an existent cluster. The consequence is that the global alert associated to a given cluster is updated. Hence, it is useful to set a date

after which new alerts cannot be inserted in the cluster. In this case, we say that the cluster is stable. This is represented by the predicate stable_cluster(Cluster_id) that specifies that the cluster identified by Cluster_id is stable. To set the date from which a given cluster is stable, we have to fix the period of time (Interval_cluster) in which an alert might be generated when an attack occurs. Let us assume that there exists in the database a relation delay_max(name_generated,IDS,delay) that gives for each attack name_generated generated by an IDS, the maximum delay this IDS needs to generate an alert associated to this attack. Then, the cluster is said to be stable when the longest delay is consumed. Third, alerts belonging to the same cluster can have occasionally some differences; this may lead to local conflicts. For instance, some alerts can specify different sources for a given attack whereas this attack has always a single source. Information of this kind: "attack x has always a single source", can be expressed as integrity constraints. These constraints are used by the alert merging function to detect local conflicts. More precisely, the alert merging function checks the integrity constraints over the global alert generated for a given cluster. If the global alert violates some integrity constraints, then this is specified in the additional data attribute of the global alert. In many cases, the correlation function will have other information to solve these violations.

this case, we shall consider that these two sources are similar and therefore we have to merge source1 and source2 to derive a unique source in the global alert. So, we have to combine the information described in source1 and source2. - The node addresses or the user names or the process names or the service names of these two sources are different. This case is straightforward. We shall simply consider that these two sources are different and, therefore, the source attribute in the global alert will contain both source1 and source2. The merging process for targets is similar. Notice also that we can specify, as we saw before, some integrity constraints about uniqueness of sources or targets, for instance. In this case, the result of merging can violate these integrity constraints. We specify this kind of violation in the attribute additionaldata of the global alert. Incidentally, redundancy must be eliminated: one source and one target can appear only once in attributes source and target of the global alert. Moreover, when a source or a target are partially described by those alerts of a given cluster, the merging function can be able to more fully describe this source or this target.

5.3.

Merging Temporal Information

5.1.

Merging Attack Classifications

The point here is to generate a value for the attribute classification of the global alert. This attribute specifies the attacks associated to the alert. In this case, the expert rule simply says that the value of classification is the union of all its values in those alerts existent in the cluster to be merged. However, notice that the relation test_IDS, previously introduced, is to be used to only insert name of attacks that are comparable from one IDS to another in the classification attribute of the global alert. Of course, redundancy must be avoided: an attack appears only once even if various alerts have detected it.

5.2.

Merging Sources/Targets of Attacks

Now, the point is to generate values for attributes source and target of the global alert. These attributes specify the source and the objective of those attacks associated to the alert. So, let source1 and source2, be two alert sources to be merged. These sources might be described by their node, user, process and service attributes. There are actually two different cases: - The node addresses and user names, process names and service names of these two sources are similar. In

As mentioned before, three temporal attributes can be associated to an alert in the DTD defined by the IDMEF: - detecttime: the attack occurs at this time. In this case, the merging function will build an interval [lower_bound,upper_bound], where lower_bound is the most ancient date that appears in the detecttime field of various alerts belonging to the cluster to be merged and upper_bound is the most recent one. The date lower_bound will be used as detecttime attribute value of the global alert and upper_bound will be added to information contained in the attribute additionaldata of the global alert. - createtime: the attack is detected at this time. Likewise previously, The merging function will build an interval [lower_bound,upper_bound]. The date lower_bound will be used as createtime attribute value of the global alert and upper_bound will be added to information contained in the attribute additionaldata of the global alert. - analyzertime: the alert is emitted at this time by the cooperation system. Dates are given by the system clock and the cooperation system must consult it to fix on the value of analyzertime of the global alert to be generated.

6.

Experiments
Experiment 1: "elementary" attacks

6.1.

We first check our approach over an attack base of 87 "elementary" attacks that is attacks that were supposed to correspond to a non decomposable step of a given scenario. For this experiment, we used two different network-based IDS: Snort [18] and e-Trust [3]. The results we obtained were as follows. The 87 attacks generated 325 alerts: 264 for Snort and 61 for e-Trust. Only 69 attacks were detected: 41 by both Snort and eTrust, 27 by Snort but not by e-Trust, 1 by e-Trust but not by Snort and 18 attacks were not detected. Notice that the signature base of Snort was tuned before the experiment to improve its initial rate of detection. Notice also that several alerts actually correspond to "weak" detection that is generation of an alert that does not precisely correspond to the attack launched. 6.1.1. Clustering results

node addresses to have similar targets. Hence, for these attacks, the similarity requirement for the target is expressed by [node]. And, if the source of the attack may be spoofed, two alerts are considered similar even though the sources are completely different. In this case, the similarity requirement for the source is [ ]. When checking our clustering function on the above attack base, we actually obtained 101 clusters. We were expecting only 95 clusters: all the problems were due to the temporal delay. But choosing a longer temporal delay would lead in other cases to improper creation of clusters. We hope that the correlation function will be able to eliminate these 6 wrong clusters as false positives. Also, notice that the largest cluster we obtained actually contains 102 alerts. It corresponds to the alerts generated by a (small!) udp flooding. However, most clusters only contain from 1 to 3 alerts. 6.1.2. Fusion results

Several points are central to obtain good clustering results: - It is crucial to properly specify the test_IDS table so that the correspondences between the classification names respectively generated by Snort and e-Trust are precisely defined. - It is necessary to correctly calibrate the temporal delay after which two alerts will not be considered similar. We first tried, as suggested by [8], with a delay of 2 seconds. This did not provide satisfactory results: many alerts did not cluster. We then tried with a longer delay but in this case, our clustering function improperly grouped several alerts. We finally decided that this delay might depend on the attack classification to be clustered. For most attacks, this delay does not exceed two or three seconds but for other attacks we choose a longer delay (for instance for udp and tcp scans). - In our implementation, the definition of the similarity between sources and between targets also depends on the attack classification of the alerts to be clustered. The approach is to specify, for each attack classification, the expected similarity requirement for the source and target. A similarity requirement is a list of attributes included in [node, service, user, process]. For most attacks, we decided to consider that two sources (resp. two targets) are similar if both the nodes and services of the sources (resp. of the targets) are similar. In this case, the similarity requirement is expressed by [node, service]. However, for some attacks (for instance a tcp-scan) we specified that it was sufficient to have similar

In this experiment, the result of the merging function are quite straightforward. This is because Snort alerts are generally more detailed than the ones generated by eTrust. As a consequence, the fusion results is close to the alerts generated by Snort. We also did not notice any global alerts that would violate some integrity constraints. However, one positive result of the approach is that the global alert generated for each cluster sometimes provides a better diagnostic for the attack classification than the alerts separately generated by Snort and e-Trust. This is because several weak detection are eliminated by crossing the alerts generated by Snort and e-Trust. One can also notice that, since 69 attacks were detected, the final objective of our approach would be to only obtain 69 alerts. This is to be compared with the 101 global alerts generated by the merging function. We already pointed out that 6 alerts were due to a too long temporal delay. But where do the other alerts come from? Several attacks were considered elementary but actually they were not. Several more elementary steps were detected by the IDS. Our approach to deal with this problem is to consider that it is the role of the correlation function to recognize these elementary steps (see the conclusion).

6.2.

Experiment 2: more "complex" attacks

We also check our approach on several "complex" attacks, that is attacks that require several steps to be launched. For instance, let us consider the following attack:
Step Step Step Step Step Step 1: 2: 3: 4: 5: 6: finger root rpcinfo <target> showmount <target> mount directory cat "++" > .rhost rlogin <target>

We call this attack "illegal nfs mount". There are 6 different steps in this attack. When this attack is launched, 9 alerts are generated: 7 by Snort and 2 by e-Trust. Our clustering function gives 5 clusters. Actually, step 5 is not detected by both Snort and e-Trust. This enables us to properly identify each (detected) steps of the attack. This result is fully satisfactory: it can be provided to the correlation function for further analysis, the objective being to correlate these 5 clusters in order to recognize one single complex attack.

7.

Conclusion

In this paper, we set the main functions required by a cooperation system built around IDS to improve intrusion detection. The alert management function stores alerts in a relational database so that they can be more easily analyzed and compared. The alert clustering function analyzes alerts and generates clusters of similar alerts. And the alert merging function allows us to refine alert clusters to bring out a global alert more informative and more accurate. These three functions have been implemented in GnuProlog [7] and are currently being tested on alerts generated by several IDS. Up to now, all these IDS are based on the detection of attack scenarios (misuse detection) but we plan to also include IDS based on the detection of abnormal behaviors (anomaly detection). One difficulty in this case will be to specify the test_IDS relation for such IDS so that it will be possible to cluster alerts generated by IDS based on the anomaly detection approach with others based on the misuse detection approach. Actually, we are currently focussing on implementing the correlation and intention recognition functions. We identified two main approaches to achieve correlation: - Explicit correlation of events is used when the security administrator is able to express some connection between events that he knows. This connection may be a logical or topologic link. The approach is mainly based on knowledge of relations between alerts and topology of information system's components that are used to describe links between equipment and applications [9]. - Implicit correlation of events is used when data analysis brings out some mappings (may be statistical ones) and relations between events. This approach is mainly based on observing groups of alerts and extracting implicit relations between them. Many works show that intrusion detection probes produce groups of alerts according to the configuration data, the traffic and the topology of information system under surveillance. Such approaches are based on learning techniques (classification [11], data mining

[22], neural network [12], ...) and should significantly reduce the amount of alerts we have to deal with. We opt for the explicit approach to carry out the correlation function. Thus, it will be possible to express explicitly known logical links between alerts. However, we also suggest a semi-explicit approach. This approach is based on the specification of attacks using LAMBDA [5]. In this language, an attack is specified using five fields: - Attack Pre-condition: A logical condition that specifies the conditions to be satisfied for the attack to succeed. - Attack Post-condition: A logical condition that specifies the effect of the attack when this attack succeeds. - Attack scenario: The combination of events the intruder performs when executing the attack. - Detection scenario: The combination of events that are necessary to detect an occurrence of the attack. - Verification scenario: A combination of events to be launched to check if the attack succeed. It is then possible to analyze the attack specifications to automatically derive two kinds of link: - Link between the post-condition of an attack A and the pre-condition of an attack B. If such a link exists, then it is possible to correlate an occurrence of attack A with an occurrence of attack B because we can assume that the intruder has performed A as a step that enables him to perform B. - Link between the post condition of an attack A and the post-condition of an attack B. If such a link exists, it is also possible to correlate occurrences of attack A and attack B because these attacks aim at achieving the same goals. These kinds of logical links can be recognized off-line to build a correlation base. This correlation base is then used to correlate alerts in order to build candidate intrusion plans of what the intruder has performed up to now. These candidate plans are derived from the alerts generated by the various IDS connected to the cooperation module. The correlation base might also be used to extrapolate these candidate plans to anticipate on what the intruder will do and to recognize his intentions. These two functions will be presented in a forthcoming paper.

8.

Acknowledgements

The author would like to thank Nora Cuppens for her help in writing this paper and for many comments on early versions of this paper. This work was funded by the DGA/CASSI as a part of the Mirador project. The author would also like to thank all the members of this project: Jacques Capoulade, Mammadou Diop, Samuel Dubus, Aldric Feuillebois (from Alcatel CIT, project leader), Patrice Carle

(ONERA), Ewan Cochevelou, Sylvain Gombault (ENSTBretagne), Laurent Heye, Ludovic Mé and Cédric Michel (SupElec Rennes).

9.

References

[1] R. Bace. Intrusion Detection. McMillan Technical Publishing, 2000. [2] J. Carrčre, F. Cuppens, M.-H. Huang and C. Saurel. Insider Detection: Using Confidentiality Security Policies for Information Flow Analysis. In preparation. [3] Computer Associates. E-Trust Intrusion Detection. 2000. [4] D. Curry and H. Debar. Intrusion Detection Message Exchange Format Data Model and Extensible Markup Language (XML) Document Type Definition. draft-itetf-idwg-idmef-xml-03.txt, February 2001. [5] F. Cuppens and R. Ortalo. LAMBDA: A Language to Model a Database for Detection of Attacks. Third Workshop on the Recent Advances in Intrusion Detection (RAID'2000), Toulouse, France, October 2000. [6] F. Cuppens. Cooperative Intrusion Detection. International Symposium "Information Superiority: Tools for Crisis & Conflict-Management". Paris, France, September, 2001. [7] M. Diaz. GNU Prolog: A Native Prolog Compiler with Constraint Solving over Finite Domains. Edition 1.4 for GNU Prolog version 1.2.1. http://gnu-prolog.inria.fr/manual/. July, 2000. [8] H. Debar and A. Wespi. The Intrusion-Detection Console Correlation Mechanism. Fourth Workshop on the Recent Advances in Intrusion Detection (RAID'2001), Davis, USA, October 2001. [9] M.-Y. Huang. A Large-scale Distributed Intrusion Detection Framework Based on Attack Strategy Analysis. First International Workshop on the Recent Advances in Intrusion Detection (RAID'98), Louvain-La-Neuve, Belgium, 1998. [10] J. Kleinwaechter. The Limitations of Intrusion Detection on High Speed Networks. First International Workshop on the Recent Advances in Intrusion Detection (RAID'98), Louvain-La-Neuve, Belgium, 1998. [11] W. Lee. Combining Knowledge Discovery and Knowledge Engineering to Build IDSs. Second

International Workshop on the Recent Advances in Intrusion Detection (RAID'99), Purdue, USA, October 1999. [12] R. Lippmann. Using Key String and Neural Networks to Reduce False Alarms and Detect New Attacks with Sniffer-Based Intrusion Detection Systems. Second International Workshop on the Recent Advances in Intrusion Detection (RAID'99), Purdue, USA, October 1999. [13] T. Lunt. IDES: An Intelligent System for Detecting Intruders. Computer Security, Threats and Countermeasures, November 1990. [14] A. Mounji and B. Le Charlier. Continuous Assessment of a Unix Configuration: Integrating Intrusion Detection and Configuration Analysis. ISOC'97 Symposium on Network and Distributed System Security, San Diego, USA, February 1997. [15] D. Mann and S. Christey. Towards a Common Enumeration of Vulnerabilities. 2nd Workshop on Research with Security Vulnerability Databases, Purdue University, West Lafayette, Indiana, January, 1999. [16] L. Mé, Z. Marrakchi, C. Michel, H. Debar and F. Cuppens. La détection d'intrusions : les outils doivent coopérer. To appear in the REE Journal. [17] P. Porras and P. Neumann. Emerald: Event Monitoring Enabling Responses to Anomalous Live Disturbances. National Security Conference, 1997. [18] M. Roesch. Snort ­ Lightweight Intrusion Detection for Networks. USENIX LISA'99, November 1999. [19] A. Valdes and D. Anderson. Statistical Methods for Computer Usage Anomaly Detection. Third International Workshop on Rough Sets and Soft Computing, San Jose, USA, 1995. [20] A. Valdes and K. Skinner. Adaptive, Model-Based Monitoring for Cyber Attack Detection. Third International Workshop on the Recent Advances in Intrusion Detection (RAID'2000), Toulouse, France, October 2000. [21] A. Valdes and K. Skinner. Probabilistic Alert Correlation. Fourth International Workshop on the Recent Advances in Intrusion Detection (RAID'2001), Davis, USA, October 2001. [22] D. Zerkle. A Data-Mining Analysis of RTID. Second International Workshop on the Recent Advances in Intrusion Detection (RAID'99), Purdue, USA, October 1999.

