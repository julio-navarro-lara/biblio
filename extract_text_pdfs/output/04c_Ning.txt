Building Attack Scenarios through Integration of Complementary Alert Correlation Methods 
Peng Ning, Dingbang Xu, Christopher G. Healey, and Robert St. Amant Cyber Defense Laboratory Department of Computer Science North Carolina State University Raleigh, NC 27695-8207 Abstract
Several alert correlation methods were proposed in the past several years to construct high-level attack scenarios from low-level intrusion alerts reported by intrusion detection systems (IDSs). These correlation methods have different strengths and limitations; none of them clearly dominate the others. However, all of these methods depend heavily on the underlying IDSs, and perform poorly when the IDSs miss critical attacks. In order to improve the performance of intrusion alert correlation and reduce the impact of missed attacks, this paper presents a series of techniques to integrate two complementary types of alert correlation methods: (1) those based on the similarity between alert attributes, and (2) those based on prerequisites and consequences of attacks. In particular, this paper presents techniques to hypothesize and reason about attacks possibly missed by IDSs based on the indirect causal relationship between intrusion alerts and the constraints they must satisfy. This paper also discusses additional techniques to validate the hypothesized attacks through raw audit data and to consolidate the hypothesized attacks to generate concise attack scenarios. The experimental results in this paper demonstrate the potential of these techniques in building high-level attack scenarios and reasoning about possibly missed attacks. ity of intrusion alerts (i.e., missed attacks and false alerts) make it a very challenging task for human users or intrusion response systems to understand the alerts and take appropriate actions. Thus, it is usually necessary to construct high-level attack scenarios from a large collection of low-level intrusion alerts. Several alert correlation techniques have been proposed to facilitate the analysis of intrusion alerts, including approaches based on the similarity between alert attributes [4, 7, 25, 27], previously known (or partially known) attack scenarios [8, 9], and prerequisites and consequences of known attacks [5, 19]. A common requirement of these approaches is that they all depend on underlying IDSs for alerts. This means the results of alert correlation are limited to the abilities of the IDSs. In particular, if the IDSs miss critical attacks, the results of alert correlation will not reflect the true attack scenario, and thus provide misleading information. In this paper, we develop a series of techniques to construct high-level attack scenarios even if the IDSs miss critical attacks. Our approach is to integrate complementary intrusion alert correlation methods and use the intrinsic relationships between possibly related attacks to hypothesize and reason about attacks missed by the IDSs. We are particularly interested in two types of alert correlation methods: correlation based on prerequisites and consequences of attacks [5,19] (which we call causal correlation methods, since they are intended to discover the causal relationships between alerts), and correlation based on similarity between alert attribute values [4, 7, 25, 27] (which we call clustering correlation method). Because these two methods correlate alerts using different mechanisms, combining them can potentially lead to better correlation results. Our main contribution in this paper is a series of techniques to integrate the causal and the clustering correlation methods, and to use the results to hypothesize and reason about attacks possibly missed by the IDSs. These techniques are critical to constructing high-

1. Introduction
It is well-known that current intrusion detection systems (IDSs) produce large numbers of alerts, including both actual and false alerts. The high volume and the low qual The authors would like to thank the anonymous reviewers for their valuable comments. This work is partially supported by the National Science Foundation (NSF) under grants ITR-0219315 and CCR-0207297, and by the U.S. Army Research Office (ARO) under grant DAAD19-021-0219.

1

level attack scenarios from low-level intrusion alerts in situations where the IDSs cannot guarantee to detect all attacks. These techniques complement the underlying IDSs by hypothesizing and reasoning about missed attacks, and thus can provide valuable additional evidences to support further intrusion investigation and response. Our approach starts with a straightforward combination of the causal and the clustering correlation methods. Specifically, we first correlate the same set of intrusion alerts with both methods independently, then combine results from the causal correlation method (represented as correlation graphs) using results from the clustering correlation method. For example, if the clustering correlation method decides that two alerts in two separate correlation graphs are very similar (e.g., same target, close timestamps, etc.), we combine these two correlation graphs into one. We then develop techniques to hypothesize about attacks possibly missed by the IDSs, especially unknown variations of known attacks. We observe that if two attacks are causally related through some intermediate attacks, they usually satisfy certain conditions (e.g., sharing the same destination IP address), even if they are not directly adjacent in a sequence of attacks. The attribute values of the corresponding alerts should also satisfy such conditions. This observation provides another opportunity to reason about the hypothesized attacks by inferring their attribute values. Moreover, the hypothesized attacks can be further validated through raw audit data. For example, we might hypothesize that variations of IMAP Authen Overflow and/or RPC Cmsd Overflow were missed by the IDSs. However, if during the target time frame, there is only IMAP traffic and no RPC traffic to the target host, we can easily conclude that the latter hypothesis is impossible. Finally, to improve the usability of the constructed attack scenarios, we present a technique to consolidate the hypothesized attacks and generate concise representations of the high-level attack scenarios. The remainder of this paper is organized as follows. The next section briefly describes a specific causal correlation method, on the basis of which our techniques are developed. Section 3 presents our techniques to integrate clustering and causal correlation methods, including approaches to hypothesizing and reasoning about attacks possibly missed by IDSs, methods to validate hypothesized attacks using raw audit data, and ways to consolidate hypothesized attacks. Section 4 reports our experimental results to test the effectiveness of our techniques. Section 5 discusses related work, and Section 6 concludes this paper and points out some future research directions. The Appendix gives more information about the alert types used in our experiments.

2. Previous Work: Alert Correlation Using Prerequisites of Attacks
The new techniques in this paper are built on the basis of the causal correlation method proposed in [19], which we briefly describe below. The approach in [19] correlates intrusion alerts using the prerequisites and consequences of attacks. Intuitively, the prerequisite of an attack is the necessary condition for the attack to be successful. For example, the existence of a vulnerable service is the prerequisite of a remote buffer overflow attack against the service. The consequence of an attack is the possible outcome of the attack. For example, gaining local access as root from a remote machine may be the consequence of a ftp buffer overflow attack. In a series of attacks where earlier ones are launched to prepare for later ones, there are usually connections between the consequences of the earlier attacks and the prerequisites of the later ones. Accordingly, we identify the prerequisites (e.g., existence of vulnerable services) and the consequences (e.g., discovery of vulnerable services) of attacks, and correlate detected attacks (i.e., alerts) by matching the consequences of previous alerts to the prerequisites of later ones. The correlation method uses logical formulas, which are logical combinations of predicates, to represent the prerequisites and consequences of attacks. For example, a scanning attack may discover UDP services vulnerable to certain buffer overflow attacks. Then the predicate UDPVulnerableToBOF (VictimIP, VictimPort) may be used to represent this discovery. The correlation model formally represents the prerequisites and consequences of known attacks as hyper-alert types. A hyper-alert type is a triple (fact, prerequisite, consequence), where fact is a set of alert attribute names, prerequisite is a logical formula whose free variables are all in fact, and consequence is a set of logical formulas such that all the free variables in consequence are in fact. Intuitively, a hyper-alert type encodes the knowledge about the corresponding type of attacks. Given a hyperalert type T = (fact, prerequisite, consequence), a type T hyper-alert h is a finite set of tuples on fact, where each tuple is associated with an interval-based timestamp [begin time, end time]. The hyper-alert h implies that prerequisite must evaluate to True and all the logical formulas in consequence might evaluate to True for each of the tuples. The correlation process is used to identify preparefor relations between hyper-alerts. Intuitively, this relation exists if an earlier hyper-alert contributes to the prerequisite of a later one. In the formal model, correlations are identified via prerequisite and consequence sets. Given a hyper-alert type T = (fact, prerequisite, consequence), the prerequisite set (or consequence set) of T , denoted P rereq (T ) (or Conseq (T )),

ICMP_PING_NMAP1

Rsh3

SCAN_NMAP_TCP2

Mstream_Zombie4

(a) CG1

(b) CG2

Figure 1. Two correlation graphs

is the set of all predicates that appear in prerequisite (or consequence). The expanded consequence set of T , denoted ExpConseq (T ), is the set of all predicates that are implied by Conseq (T ). (This is computed using the implication relationships between predicates [19].) Thus, Conseq (T )  ExpConseq (T ). Given a type T hyper-alert h, the prerequisite set, consequence set, and expanded consequence set of h, denoted P rereq (h), Conseq (h), and ExpConseq (h)), respectively, are the predicates in P rereq (T ), Conseq (T ), and ExpConseq (T ) with arguments replaced by the corresponding attribute values of each tuple in h. Each element in P rereq (h), Conseq (h), or ExpConseq (h) is associated with the timestamp of the corresponding tuple in h. Hyper-alert h1 prepares for hyper-alert h2 if there exist p  P rereq (h2 ) and c  ExpConseq (h1 ) such that p = c and c.end time < p.begin time. A hyper-alert correlation graph is used to represent a set of correlated hyper-alerts. A hyper-alert correlation graph CG = (N , E ) is a connected directed acyclic graph, where N is a set of hyper-alerts and for each pair n1 , n2  N , there is a directed edge from n1 to n2 in E if and only if n1 prepares for n2 . For brevity, we refer to a hyper-alert correlation graph as a correlation graph in this paper.

correlation graphs shown in Figures 1(a) and 1(b) (The string inside each node is a hyper-alert type name followed by an alert ID), if the clustering method groups SCAN NMAP TCP2 and Rsh3 in the same cluster based on their common source and destination IP addresses, we consider integrating these two graphs together. Because this simple technique works well in practice, our main focus in this paper is on the second step: how to identify causal relationships between alerts in different correlation graphs. This is challenging, since we must deal with missed attacks that cause an attack scenario to split into multiple correlation graphs. To meet our goal, we developed a series of techniques to integrate multiple correlation graphs. We start with a straightforward method, and gradually add more sophisticated techniques into our approach. Without loss of generality, we assume we integrate two correlation graphs in the following discussion.

3.1. Combining Related Correlation Graphs
A straightforward approach to combining two correlation graphs is to use the prior knowledge of attacks and the alert timestamp information to hypothesize about the possible causal relationships between alerts in different correlation graphs. For example, suppose an attacker uses nmap to find out a vulnerable service, then uses a buffer overflow attack to compromise that service, and finally installs and starts a DDOS daemon program. When we observe an earlier SCAN NMAP TCP and a later Mstream Zombie alert in two correlation graphs that are identified for integration, we may hypothesize that the SCAN NMAP TCP alert indirectly prepares for the Mstream Zombie alert through an unknown attack (or an unknown variation of a known attack, e.g., a variation of the above buffer overflow attack). As a result, we would add a hypothesized indirect causal relationship between these two alerts. To further characterize this intuition and facilitate later discussion, we introduce two definitions. (Note that Definition 1 is based on the model in [19], which has been described briefly in Section 2.) For convenience, we denote the type of a hyper-alert h as T ype(h). Definition 1 Given two hyper-alert types T and T , we say T may prepare for T if ExpConseq (T ) and P rereq (T ) share at least one predicate (with possibly different arguments). Given a set T of hyper-alert types, we say T may indirectly prepare for T w.r.t. T if there exists a sequence of hyper-alert types T, T1 , ..., Tk , T such that (1) all these hyper-alert types are in T , and (2) T may prepare for T1 , Ti may prepare for Ti+1 , where i = 1, 2, ..., k - 1, and Tk may prepare for T . Intuitively, given two hyper-alert types T and T , T may

3. Integrating Complementary Alert Correlation Methods
To integrate the causal and the clustering correlation methods, we combine correlation graphs generated by the causal method using the results from the clustering methods. Intuitively, if the IDSs miss certain attacks, alerts from the same attack scenario may be split across several correlation graphs. The clustering methods have the potential to identify the common features shared by these alerts, and therefore to help re-integrate the relevant correlation graphs together. The integration process can be conceptually divided into two steps: (1) identify the correlation graphs to be integrated, and (2) determine possible causal relationships between alerts in different correlation graphs. In this paper, we choose a simple technique for the first step: we integrate two correlation graphs when they both contain alerts from a common cluster. For example, given the two

ICMP_PING_NMAP1

ICMP_PING_NMAP1

SCAN_NMAP_TCP2
SCAN_NMAP_TCP2

IMAP_Authen_Overflow5
Rsh3

FTP_Glob_Expansion6

Rsh3
Mstream_Zombie4

Mstream_Zombie4

Figure 2. A straightforward combination of CG1 and CG2

Figure 3. Integration of CG1 and CG2 with hypotheses of missed attacks

prepare for T if there exist a type T hyper-alert h and a type T hyper-alert h such that h prepares for h .
Definition 2 Given a set T of hyper-alert types and two hyper-alerts h and h , where T ype(h) and T ype(h )  T and h .begin time > h.end time, h may indirectly prepare for h if T ype(h) may indirectly prepare for T ype(h ) w.r.t. T . Given a sequence of hyper-alerts h, h1 , ..., hk , h where k > 0, h indirectly prepares for h if h prepares for h1 , hi prepares for hi+1 for i = 1, ..., k - 1, and hk prepares for h . Intuitively, h may indirectly prepare for h if there could exist a path from h to h in a correlation graph (with additional hyper-alerts), while h indirectly prepares for h if such hyper-alerts do exist. We are particularly interested in the case where h may indirectly prepare for h but there do not exist additional hyper-alerts showing that h indirectly prepares for h . Indeed, a possible reason for such a situation is that the IDSs miss some critical attacks, which, if detected, would lead to additional hyper-alerts showing that h indirectly prepares for h . A simple way to take advantage of the above observation is to assume a possible causal relationship between hyper-alerts h and h if they belong to different correlation graphs and h may indirectly prepare for h . Let us continue the example in Figure 1. If SCAN NMAP TCP may prepare for FTP Glob Expansion, which may prepare for Rsh, then we have SCAN NMAP TCP may indirectly prepare for Rsh. Thus, we may hypothesize that SCAN NMAP TCP2 indirectly prepares for Rsh3. We add a virtual edge, displayed in a dashed line, from SCAN NMAP TCP2 to Rsh3 in Figure 2, indicating that there may be some attacks between them that are missed by the IDSs. Though this simple approach can integrate related hyper-alert correlation graphs and hypothesize about possible causal relationships between alerts, it is limited in several ways. First, the virtual edges generated with this approach provide no information about attacks possibly missed by the IDSs. Second, the virtual edges are deter-

mined solely on the basis of prior knowledge about attacks. There is no "reality check." Though a clustering correlation method combines several hyper-alert correlation graphs together, the hypothesized virtual edges are not necessarily true due to the limitations of the clustering correlation method and the lack of information about the missed attacks.

3.2. Hypothesizing Missed Attacks
The may-prepare-for and may-indirectly-prepare-for relations identified in Definitions 1 and 2 provide additional opportunities to hypothesize and reason about missed attacks, especially unknown variations of known attacks. Consider two hyper-alerts h and h that belong to different correlation graphs prior to integration. If h may indirectly prepare for h , we can then identify possible sequences of hyper-alert types in the form of T1 , T2 , ..., Tk such that T ype(h) may prepare for T1 , Ti may prepare for Ti+1 , i = 1, 2, ..., k -1, and Tk may prepare for T ype(h ). These sequences of hyper-alert types are candidates of attacks possibly missed by the IDSs. (More precisely, variations of these attacks, which could be used by an attacker and then missed by the IDSs, are the actual candidates of missed attacks.) We can then search in the alerts and/or the raw audit data between h and h to check for signs of these attacks (or their variations). For example, to continue the example in Figure 2, we may hypothesize that variations of either IMAP Authen Overflow, or FTP Glob Expansion, or both may have been missed by the IDSs based on our prior knowledge about attacks. To better present these hypotheses, we may add the hypothesized attacks into the correlation graph as virtual nodes (displayed in gray). Figure 3 shows the resulting correlation graph. To facilitate hypothesizing about missed attacks, we encode our knowledge of the relationships between hyperalert types in a hyper-alert type graph, or simply a type graph. Let us first introduce the concept of equality constraint, which was originally defined in [20], to help for-

mally describe the notion of type graph. Definition 3 (equality constraint [20]) Given a pair of hyper-alert types (T1 , T2 ), an equality constraint for (T1 , T2 ) is a conjunction of equalities in the form of u1 = v1  ˇ ˇ ˇ  un = vn , where u1 , ˇ ˇ ˇ , un are attribute names in T1 and v1 , ˇ ˇ ˇ , vn are attribute names in T2 , such that there exist p(u1 , ˇ ˇ ˇ , un ) and p(v1 , ˇ ˇ ˇ , vn ), which are the same predicate with possibly different arguments, in ExpConseq (T1 ) and P rereq (T2 ), respectively. Given a type T1 hyper-alert h1 and a type T2 hyper-alert h2 , h1 and h2 satisfy the equality constraint if there exist t1  h1 and t2  h2 such that t1 .u1 = t2 .v1  ˇ ˇ ˇ  t1 .un = t2 .vn evaluates to True. An equality constraint characterizes the relationships between the attribute values of two hyper-alerts when one of them prepares for the other. There may be several equality constraints for a pair of hyper-alert types. However, if a type T1 hyper-alert h1 prepares for a type T2 hyper-alert h2 , then h1 and h2 must satisfy at least one equality constraint. Indeed, h1 preparing for h2 is equivalent to the conjunction of h1 and h2 satisfying at least one equivalent constraint and h1 occurring before h2 [20]. Given a set of hyper-alert types (representing the known attacks), we can derive all possible may-prepare-for relations between them together with the corresponding equality constraints. This information can help us understand how these known attacks may be combined to launch sequences of attacks, and thus hypothesize about which attacks (more precisely, their variations) may be missed when we observe alerts that may indirectly prepare for each other. The following definition formally captures this intuition. Definition 4 Given a set T of hyper-alert types, a (hyperalert) type graph T G over T is a quadruple (N, E, T, C ), where (1) (N, E ) is a directed graph, (2) T is a bijective mapping from N to T , which maps each node in N to a hyper-alert type in T , (3) there is an edge (n1 , n2 ) in E if and only if T (n1 ) may prepare for T (n2 ), and (4) C is a mapping that maps each edge (n1 , n2 ) in E to a set of equality constraints associated with (T (n1 ), T (n2 )).

n1:ICMP_PING_NMAP
{n1.DestIP=n2.DestIP}

n2:SCAN_NMAP_TCP
{n2.DestIP=n3.DestIP} {n2.DestIP=n4.DestIP}

n3:IMAP_Authen_Overflow

n4:FTP_Glob_Expansion
{n4.DestIP=n5.SrcIP, n4.DestIP=n5.DestIP} {n4.DestIP=n6.SrcIP, n4.DestIP=n6.DestIP}

{n3.DestIP=n5.SrcIP, n3.DestIP=n5.DestIP} {n3.DestIP=n6.SrcIP, n3.DestIP=n6.DestIP}

n5:Rsh
{n5.SrcIP=n6.SrcIP, n5.DestIP=n6.DestIP, n5.SrcIP=n6.DestIP, n5.DestIP=n6.SrcIP}

n6:Mstream_Zombie

Figure 4. An example type graph Mstream Zombie}. (We include the specifications of these hyper-alert types in Appendix A.) We can compute the type graph over T as shown in Figure 4. The string inside each node is the node name followed by the hyper-alert type name. The label of each edge is the corresponding set of equality constraints. Obviously, given multiple correlation graphs that may be integrated together, we can hypothesize about possibly missed attacks that break the attack scenario according to the type graph. Let us revisit the example in Figure 1. Given the type graph in Figure 4, we can systematically hypothesize that the IDSs may have missed variations of IMAP Authen Overflow and/or FTP Glob Expansion attacks. As a result, we obtain the integrated correlation graph shown in Figure 3.

3.3. Reasoning about Missed Attacks
Consider nodes n2, n3, and n5 in Figure 4. There is an equality constraint n2.DestIP = n3.DestIP associated with (n2, n3), and two equality constraints n3.DestIP = n5.SrcIP and n3.DestIP = n5.DestIP associated with (n3, n5). These imply that n2.DestIP = n5.SrcIP or n2.DestIP = n5.DestIP . In other words, if a type SCAN NMAP TCP hyper-alert indirectly prepares for a type Rsh hyper-alert (through a type IMAP Authen Overflow hyper-alert), they must satisfy one of these two equations. We obtain the same equations if we consider nodes n2, n4, and n5 in Figure 4. In general, we can derive constraints for two hyperalert types when one of them may indirectly prepare for the other. Informally, we call such a constraint an indirect equality constraint. These constraints can be used to study whether two hyper-alerts in two different correlation

Example 1 Consider the following set of hyper-alert types: T ={ICMP PING NMAP, SCAN NMAP TCP, IMAP Authen Overflow, FTP Glob Expansion, Rsh,

graphs could be indirectly related. This in turn allows us to filter out incorrectly hypothesized attacks. Indirect equality constraints can be considered a generalization of the equality constraints specified in Definition 3. In this paper, we combine the terminology and simply refer to an indirect equality constraint as an equality constraint when it is not necessary to distinguish between them. To take advantage of the above observation, we must derive indirect equality constraints. Algorithm 1 (shown in Figure 5) outlines an approach for generating the set of indirect equality constraints between two hyper-alert types T and T where T may indirectly prepare for T . Intuitively, for each pair of hyper-alert types T and T , Algorithm 1 identifies all paths from T to T in the type graph, and computes an indirect equality constraint for each combination of equality constraints between consecutive hyper-alert types along the path. The basic idea is to propagate the equality relationships between attributes of hyper-alert types. Each indirect equality constraint is labeled with the corresponding path that produces the constraint. This information provides further guideline in hypothesizing missed attacks. The usefulness of Algorithm 1 is guaranteed by Lemma 1. Lemma 1 Consider a type graph T G and two hyperalerts h and h , where T ype(h) and T ype(h ) are in T G. Assume Algorithm 1 outputs a set C of equality constraints for T ype(h) and T ype(h ). If C is non-empty and h indirectly prepares for h , then h and h must satisfy at least one equality constraint in C . PROOF. According to Definition 2, if h indirectly prepares for h , there must exists a sequence of hyper-alerts h1 , ..., hk , where k > 0, such that h prepares for h1 , hi prepares for hi+1 for i = 1, ..., k - 1, and hk prepares for h . Thus, we have T ype(h) may prepare for T ype(h1), T ype(hi ) may prepare for T ype(hi+1 ) for i = 1, ..., k -1, and T ype(hk ) may prepare for T ype(h ). Following the convention of Algorithm 1, we denote T ype(h) as T0 , T ype(hi ) as Ti , where i = 1, ..., k , and T ype(h ) as Tk+1 . It is easy to see there must be a path T0 , T1 , ..., Tk+1 in the corresponding type graph T G. For convenience, we also denote h as h0 , and h as hk+1 . According to [20], if hi prepares for hi+1 , then hi and hi+1 must satisfy at least one equality constraint for (Ti , Ti+1 ). For i = 0, 1, ..., k , we denote the constraint hi and hi+1 satisfy as Ci . According to Figure 5, Algorithm 1 will process the path T0 , T1 , ..., Tk+1 (in step 2) and the combination of equality constraints C0 , C1 , ..., Ck+1 that h0 , h1 , ..., hk+1 satisfy (in step 4). Now consider steps 5 to 9. For each S (T0 .ai ), we can prove by induction that all attributes Tj .b added into

S (T0 .ai ) are equal to T0 .ai , since each addition is based on a conjunct Tj -1 .a = Tj .b, where Tj -1 .a is already in S (T0 .a). Further because step 9 removes the attributes of Tj -1 , only attributes of Tk+1 remain in S (T0 .ai ), i = 1, 2, ..., l. Thus, after step 9, each S (T0 .ai ) includes all the attributes of Tk+1 that are equal to T0 .ai , where i = 1, 2, ..., l. Steps 10 to 13 then transform these equality relations into a conjunctive formula ec. Since the sequence of constraints Ci , i = 0, 1, ..., k , where each Ci is satisfied by hi and hi+1 , is used in the above process, we can easily conclude that h0 (h) and hk+1 (h ) satisfy ec. Thus, if h indirectly prepares for h , they must satisfy at least one equality constraint in C . 2 Note that Algorithm 1 is meant to illustrate the basic idea behind computing indirect equality constraints. In practice, we compute the indirect equality constraints for all pairs of hyper-alert types simultaneously as we traverse through the paths between a pair of hyper-alert types, and thus significantly reduce the required computation time. Moreover, we need to perform this computation only once after we determine the set of known attacks. Thus, the performance of this algorithm will not impact the performance of intrusion analysis greatly. Example 2 Consider the type graph in Figure 4 and two hyper-alert types SCAN NMAP TCP (node n2) and Rsh (node n5). Using Algorithm 1, we can easily compute the indirect equality constraints for them: {n2.DestIP = n5.DestIP , n2.DestIP = n5.SrcIP }. Both indirect equality constraints are labeled with the following two paths: SCAN NMAP TCP, IMAP Authen Overflow, Rsh and SCAN NMAP TCP, FTP Glob Expansion, Rsh . Moreover, we can derive the sets of equality constraints for all pairs of hyper-alert types in Figure 4 where one of the pair may (indirectly) prepare for the other. Table 1 shows the results. (To save space, we use node names to represent the corresponding hyper-alert types.) Each cell in the table contains the equality constraints for the hyper-alert types in the given row and the column, where the row may (indirectly) prepare for the column. The equality constraints derived for indirectly related hyper-alert types can be used to improve the hypotheses of missed attacks. Given two correlation graphs G and G that may be integrated together, we can check each pair of hyper-alerts h and h , where h may indirectly prepare for h , and h and h belong to G and G , respectively. If h and h satisfy at least one equality constraint for (T ype(h), T ype(h )), then we have consistent evidence that supports the hypothesis that h indirectly prepares for h (through some missed attacks). Moreover, for each equality constraint ec that h and h satisfy, we

Algorithm 1. Computation of Indirect Equality Constraints Input: A type graph T G, and two hyper-alert types T and T in T G, where T may indirectly prepare for T . Output: A set of equality constraints for T and T . Method: 1. Let Result = . 2. For each path T , T1 , ..., Tk , T from T to T in T G 3. Denote T as T0 , and T as Tk+1 . 4. For each combination of constraints C1 , C2 , ..., Ck+1 , where Ci is an equality constraint for (Ti-1 , Ti ) 5. Let S (T0 .ai ) = {T0 .ai }, where T0 .ai , i = 1, 2, ..., l, are all the attributes of T0 that appear in C1 . 6. For j = 1 to k + 1 7. For each conjunct Tj -1 .a = Tj .b in Cj 8. For each S (T0 .ai ) that contains Tj -1 .a, let S (T0 .ai ) = S (T0 .ai )  {Tj .b}. 9. Remove variables of Tj -1 from each S (T0 .ai ), i = 1, 2, ..., l. 10. Let temp = . 11. For each non-empty S (T0 .ai ) and each Tk+1 .b in S (T0 .ai ) 12. Let temp = temp  {T0 .ai = Tk+1 .b}. 13. Let ec be the conjunction of all elements in temp. 14. If ec is in Result then 15. Let Label(ec) = Label(ec)  { T, T1 , ..., Tk , T } 16. else Let Label(ec) = { T, T1 , ..., Tk , T }, and Result = Result  {ec}. 17. Return Result.

Figure 5. Algorithm to compute indirect equality constraints for two hyper-alert types Table 1. Equality constraints for hyper-alert types in Figure 4 where one may (indirectly) prepare for the other.
n1 n2 n3 n4 n5 n1 / / / / / n2 {n1.DestIP=n2.DestIP} / / / / n3 {n1.DestIP=n3.DestIP} {n2.DestIP=n3.DestIP} / / / n4 {n1.DestIP=n4.DestIP} {n2.DestIP=n4.DestIP} / / / n5 {n1.DestIP=n5.DestIP, n1.DestIP=n5.SrcIP} {n2.DestIP=n5.DestIP, n2.DestIP=n5.SrcIP} {n3.DestIP=n5.DestIP, n3.DestIP=n5.SrcIP} {n4.DestIP=n5.DestIP, n4.DestIP=n5.SrcIP} / n6 {n1.DestIP=n6.DestIP, n1.DestIP=n6.SrcIP} {n2.DestIP=n6.DestIP, n2.DestIP=n6.SrcIP} {n3.DestIP=n6.DestIP, n3.DestIP=n6.SrcIP} {n4.DestIP=n6.DestIP, n4.DestIP=n6.SrcIP} {n5.SrcIP=n6.SrcIP, n5.DestIP=n6.DestIP, n5.SrcIP=n6.DestIP, n5.DestIP=n6.SrcIP} /

n6

/

/

/

/

/

can add the paths in Label(ec) into the integrated correlation graph. Note that each path in Label(ec) is in the form of T ype(h), T1, ..., Tk , T ype(h ). T ype(h) and T ype(h ) are then merged with h and h , respectively, and the rest of the path is added as a virtual path (i.e., virtual nodes and edges) from h to h .

3.4. Validating through Raw Audit Data
The hypothesized attacks can be further validated using raw audit data. For example, we may hypothesize there is a variation of FTP Glob Expansion attack between a SCAN NMAP TCP alert and a Rsh alert. However, if there is no ftp activity related to the victim host between these two alerts, we can easily conclude that our hypothesis is incorrect. By doing so we can further narrow the hypothesized attacks down to meaningful ones. To take advantage of this observation, we extend our model to associate a "filtering condition" with each hyper-

alert type. Assume that the raw audit data set consists of a sequence of audit records, and we can extract a set of attributes from each audit record directly, or through inference. For example, we may extract the source IP address from a tcpdump record directly, or infer the type of service using the port and payload information. For the sake of presentation, we call such attributes obtained from the raw audit data audit attributes. Given a set A of audit attributes and a hyper-alert type T , a filtering condition for T w.r.t. A is a logical formula involving audit attribute names in A, which evaluates to True or False if the audit attribute names are replaced with specific values. Intuitively, a filtering condition for T w.r.t. A must be True if an attack corresponding to T or its variations indeed happen. Using filtering conditions is indeed straightforward. When we hypothesize a sequence of missed attacks based on two hyper-alerts h and h , we know that all the times-

ICMP_PING_NMAP1

3.5. Consolidating Hypothesized Attacks
In the earlier discussion, we focused on hypothesizing and reasoning about missed attacks. However, this method does not consider the possibility that the same hypothesized attack could be related to multiple hyperalerts in different correlation graphs. As a result, the integrated correlation graph with hypothesized attacks could be overly complex. In particular, there could be multiple hypothesized attacks for one missed attack. Though it is possible that the same hypothesized attacks are repeated multiple times, having too many uncertain details reduces the usability of the integrated correlation graph. To deal with the above problem, we consolidate the hypothesized attacks based on their types and their inferred attribute values. The general idea is to merge the hypothesized attacks (and thus reduce the complexity of the integrated correlation graph) as long as it is possible that the hypothesized attacks to be merged are the same attack. In other words, we aggregate the same type of hypothesized attacks if their inferable attribute values are consistent. The attribute values of a hypothesized attack can be inferred from the hyper-alerts that lead to this hypothesis. For example, if we hypothesize that an IMAP Authen Overflow attack after a SCAN NMAP TCP alert and before a Rsh alert such that SCAN NMAP TCP prepares for IMAP Authen Overflow, which then prepares for Rsh, then from Table 1 we know that SCAN NMAP TCP and IMAP Authen Overflow have the same destination IP address, and the destination IP address involved in IMAP Authen Overflow is the same as either the source or the destination IP address in Rsh. In general, we can use the equality constraints between the actual alerts and the hypothesized attacks to infer the possible attribute values of these attacks. As a special attribute, we estimate the timestamp of a hypothesized attack with a possible range. If an attack T is hypothesized with two actual alerts h and h , where h occurs before h , then the possible range of T 's timestamp is (h.end time, h .begin time). To reduce the number of hypothesized attacks and make the integrated correlation graph easy to understand, we take an aggressive approach. Specifically, we aggregate two hypothesized attacks together if they (1) belong to the same type, (2) share the same values on their common inferable attributes, and (3) the ranges of their timestamps overlap. An example of consolidation is what we performed in our experiments, which consolidated about 300 hypothesized attacks into 16. In the following, we outline the approach to consolidating hypothesized attacks. The consolidation process is performed in three steps. First, we get the inferable attribute values for all hypothesized attacks. Second, we partition the hypothesized at-

SCAN_NMAP_TCP2

IMAP_Authen_Overflow5

Rsh3

Mstream_Zombie4

Figure 6. Integration of CG1 and CG2 after refinement with raw audit data

tamps of the hypothesized attacks are between those of h and h . Thus, to validate a hypothesized attack, we can search through the raw audit records during the aforementioned time period, and evaluate the filtering condition for the hypothesized attack using the values of the audit attributes extracted from each raw audit record. To continue the earlier example, we may associate a filtering condition protocol=ftp with the hyper-alert type FTP Glob Expansion. If there is no ftp traffic between the hyper-alerts SCAN NMAP TCP2 and Rsh3, this condition will evaluate to False for all audit records, and we can conclude that no ftp based attack is missed by the IDSs. As a result, the integrated correlation graph in Figure 3 can be refined to the one in Figure 6. A limitation of using filtering conditions is that human users must specify the conditions associated with each hyper-alert type. It has at least two implications. First, it could be time consuming to specify such conditions for every known attack. Second, human users may make mistakes during the specification of filtering conditions. In particular, a filtering condition could be too specific to capture the invariant among the variations of a known attack, or too general to filter out enough incorrect hypotheses. Nevertheless, we observe that any filtering condition may help reduce incorrectly hypothesized attacks, even if it is very general. In our experiments, we simply use the protocols over which the attacks are carried out as filtering conditions. It is interesting to study how to get the "right" way to specify filtering conditions. We consider this problem outside of the scope of this paper; we will investigate it in our future work. Another issue is the execution cost. To filter out a hypothesized attack with a filtering condition, we have to examine every audit record during the period of time when the attack could have happened. Though there are many ways to optimize the filtering process (e.g., indexing, concurrent examination), the cost is not negligible, especially when the time period is large. Thus, filtering conditions are more suitable for off-line analysis such as forensic analysis.

tacks into groups such that all hypothesized attacks in the same group have the same hyper-alert type, their attribute values do not have conflict values (i.e., if two hypothesized attacks have inferable values on the same attribute, these two values should be the same), and possible ranges of their timestamps overlap. We then aggregate each group into one hypothesized attack. Third, we merge virtual edges between the same pair of (aggregated) hypothesized attacks. The resulting correlation graph is the final integrated correlation graph. Among the three steps, the only non-trivial step is the inference of attribute values for hypothesized attacks. We achieve this by revising Algorithm 1. In Steps 5 o 9, in addition to maintaining the sets S (T0 .ai ) only for attributes of T0 , we construct such sets for all attributes of each hyper-alert type Tj -1 that appear in the equality constraint Cj . As a result, for each combination of equality constraints mentioned in Step 4 and each Tj , j = 1, 2, ..., k , we can get an equality constraint for T and each Tj , denoted ecj , and another equality constraint for Tj and T , denoted ecj . Given a type T hyper-alert h and a type T hyper-alert h , if T , T1 , ..., Tk , T are the hypothesized path that leads to h indirectly preparing for h and C1 , C2 , ..., Ck+1 are the corresponding sequence of equality constraints, then for each hypothesized attack Tj , Tj must satisfy both ecj and ecj . Thus, we can infer the attributes involved in ecj and ecj using h and h . To keep this information, each Tj should maintain ecj and ecj w.r.t. T and T . We shall point out that each hypothesized attack may correspond to multiple actual attacks in the consolidated correlation graph. In other words, each hypothesized attack in an integrated correlation graph is indeed a place holder for one or several possible attacks.

FTP_Syst67243

Sadmind_Ping67343

(a) CGa

Rsh67558 Email_Almail_Overflow67529 Rsh67559 Email_Almail_Overflow67304 Rsh67560 Rsh67553 Rsh67542 Rsh67549 Rsh67550 Rsh67540 Rsh67543 Rsh67545 Mstream_Zombie67777 Rsh67546 Rsh67547 Rsh67562 Rsh67535 Rsh67536 Rsh67538 Rsh67539 Mstream_Zombie67563 Mstream_Zombie67767 Stream_DoS67773 Mstream_Zombie67537 Mstream_Zombie67776 Mstream_Zombie67554

(b) CGb

Figure 7. Two correlation graphs constructed from LLDOS 1.0 inside traffic

4. Experimental Results
To examine the effectiveness of the proposed techniques, we performed a series of experiments using one of the 2000 DARPA intrusion detection scenario specific data sets, LLDOS 1.0 [15]. LLDOS 1.0 contains a series of attacks in which an attacker probed, broke-in, installed the components necessary to launch a Distributed Denial of Service (DDOS) attack, and actually launched a DDOS attack against an off-site server. The network audit data were collected in both the DMZ and the inside parts of the evaluation network. We used RealSecure Network Sensor 6.0 [11] as the IDS sensor to generate alerts, and the NCSU Intrusion Alert Correlator [18] to correlate these alerts into correlation graphs. To validate the hypothesized attacks using raw audit data, we used Ethereal [3], a network protocol analyzer, to extract information from the raw tcpdump file (i.e., the network audit data). We used Graphviz [2] to visualize correlation graphs.

Our current implementation is still semi-automatic. Our prototype can automatically decide what hyper-alert correlation graphs to integrate, hypothesize possibly missed attacks, and consolidate the hypothesized attacks. However, the validation of hypothesized attacks with raw audit data still has to be handled semi-manually. Specifically, we use Ethereal [3] to extract the protocol information for each packet, and then validate the hypothesized attacks accordingly. We are currently refining our implementation so that all steps can be automated. In our experiments, we use a simple clustering correlation method. That is, we cluster alerts together as long as they involve the same destination IP address. Since our goal is to examine the effectiveness of the integration techniques, we believe this is acceptable for our experiments. In practice, more sophisticated clustering correlation methods (e.g., those proposed in [27]) are certainly needed for better performance. To test the ability of our techniques to hypothesize and reason about missed attacks, we dropped all Sadmind Amslverify Overflow alerts that RealSecure Network Sensor detected in LLDOS1.0. As a

result, the attack scenarios that the Intrusion Alert Correlator output before dropping these alerts are all split into multiple parts, some of which become individual, uncorrelated alerts. Figure 7 shows two of these correlation graphs constructed from the inside traffic in LLDOS 1.0. Now let us focus on the correlation graphs in Figure 7. As mentioned earlier, we cluster alerts together if they share the same destination IP address. Since the destination IP addresses of both Sadmind Ping67343 (in Figure 7(a)) and Rsh67553 (in Figure 7(b)) are 172.16.112.50, they belong to the same cluster. We integrate two correlation graphs as long as they both have alerts in the same cluster. Thus, Figures 7(a) and 7(b) should be integrated together. We consider all types of alerts generated by the RealSecure Network Sensor 6.0 in our type graph. The specification of the corresponding hyper-alert types are given in Appendix A, and the type graph is given in Figure 8. For space reasons, we did not put the isolated nodes (the nodes which do not have edges connecting to them) into the type graph. Based on the type graph, we can easily hypothesize that variations of FTP Syst, HTTP Shells, and Sadmind Amslverify Overflow could have been missed by the IDS. For example, there could be variations of Sadmind Amslverify Overflow between Sadmind Ping and any later Rsh alert. By reasoning about the hypothesized attacks using equality constraints, we rule out some of these hypothesized attacks. For example, the destination IP address of Sadmind Ping67343 is 172.16.112.50, which is different from either the source or the destination IP address of Rsh67543. Thus, Sadmind Ping67343 cannot indirectly prepare for Rsh67543 through a variation of Sadmind Amslverify Overflow. The hypothesized attacks are further validated using the raw audit data. In our experiments, we use the inferred attribute values and the protocol that carries the corresponding attack as the filtering condition for each hyper-alert type. For example, the filtering condition for (variations of) FTP Put is protocol = f tp plus all the inferable attributes. All the hypothesized attacks are then checked using the audit records between the hyper-alerts that result in the hypothesized attacks. For example, we search all the IP packets between Sadmind Ping67343 and Rsh67560 for RPC packets in order to validate a hypothesized (variation of) Sadmind Amslverify Overflow attack (which is a RPC based attack). We continue the above process to integrate the resulting correlation graph with additional ones generated by the Intrusion Alert Correlator. We are able to further integrate hyper-alerts Sadmind Ping67286 and Sadmind Ping67341, which are both uncorrelated

alerts. As a slight difference, FTP Put are hypothesized during both integration processes, but all hypothesized FTP Put attacks are invalidated later using raw audit data. In other words, we find no ftp activities involving the corresponding host during the time frame when the hypothesized attacks might happen. Figure 9 shows the integrated correlation graph after the hypothesized attacks are consolidated. The hypothesized attacks are shown in gray, and are labeled by the corresponding hyper-alert type followed by an ID to distinguish between different instances of the same type of attacks. Now let us examine the integrated correlation graph in Figure 9. According to the description of the data sets [15], the three Sadmind Amslverify Overflow attacks and the prepare-for relations between these attacks and the other alerts are all hypothesized correctly. However, the FTP Put and HTTP Shells attacks are hypothesized incorrectly. In addition, the gray Rsh nodes in Figure 9 result from the different combinations of equality constraints between hyper-alert types (Their attribute values were inferred through existing alerts, and they cannot be further consolidated with other alerts or hypothesized attacks. In our future work, we may look for a way to further reduce them). We also performed the experiments using the DMZ data set in LLDOS 1.0. Similar to the inside data set, we deliberately dropped all Sadmind Amslverify Overflow alerts from those generated by RealSecure Network Sensor 6.0. Using the type graph in Figure 8, we generated three integrated correlation graphs in Figure 10, in which hypothesized attacks are shown in gray. Based on the reasoning of the hypothesized attacks, we know the destination IP addresses of Sadmind Amslverify Overflow4, and Sadmind Amslverify Overflow5 Sadmind Amslverify Overflow6 are 172.16.115.20, 172.16.112.10 and 172.16.112.50, respectively. Similarly, the destination IP address of HTTP Shells2 is 172.16.112.50. According to the description of the data sets [15], the Sadmind Amslverify Overflow attacks are all hypothesized correctly, while the HTTP Shells attack is hypothesized incorrectly. These experiment results (including LLDOS 1.0 inside and DMZ data sets) indicate that though the proposed techniques can identify missed attacks, they are still not perfect. Nevertheless, the proposed techniques have already exceeded the limitation of IDSs. The experimental evaluation reported in this paper is still preliminary, though they have demonstrated the potential of the proposed techniques. To further understand the capability of these techniques, a more detailed, quantitative evaluation is required. We will perform such eval-

{n17.DestIP=n6.DestIP ^n17.DestPort=n6.DestPort}

{n17.DestIP=n9.DestIP ^n17.DestPort=n9.DestPort} {n17.DestIP=n11.DestIP ^n17.DestPort=n11.DestPort} {n17.DestIP=n10.DestIP ^n17.DestPort=n10.DestPort}

n17:Port_Scan

{n17.DestIP=n18.DestIP ^n17.DestPort=n18.DestPort} n10:Email_Ehlo {n20.DestIP=n10.DestIP ^n20.DestPort=n10.DestPort} {n17.DestIP=n19.DestIP ^n17.DestPort=n19.DestPort} n18:FTP_Pass {n20.DestIP=n18.DestIP ^n20.DestPort=n18.DestPort}

{n10.SrcIP=n11.SrcIP ^n10.DestIP=n11.DestIP} n11:Email_Turn

Figure 8. The type graph used in our experiments

{n17.DestIP=n5.DestIP ^n17.DestPort=n5.DestPort} {n20.DestIP=n19.DestIP ^n20.DestPort=n19.DestPort} n19:FTP_User {n20.DestIP=n11.DestIP ^n20.DestPort=n11.DestPort} {n17.DestIP=n12.DestIP ^n17.DestPort=n12.DestPort} n20:UDP_Port_Scan {n20.DestIP=n9.DestIP ^n20.DestPort=n9.DestPort} {n9.DestIP=n6.DestIP} n9:Email_Debug {n9.DestIP=n8.SrcIP, n9.DestIP=n8.DestIP}

{n9.DestIP=n7.SrcIP, n9.DestIP=n7.DestIP}

{n5.DestIP=n7.SrcIP, n5.DestIP=n7.DestIP}

{n20.DestIP=n5.DestIP ^n20.DestPort=n5.DestPort} {n20.DestIP=n6.DestIP ^n20.DestPort=n6.DestPort}

n5:Email_Almail_Overflow

{n5.DestIP=n6.DestIP}

{n3.DestIP=n6.DestIP} {n17.DestIP=n1.DestIP ^n17.DestPort=n1.DestPort} {n12.DestIP=n3.DestIP} {n20.DestIP=n12.DestIP ^n20.DestPort=n12.DestPort} n12:FTP_Syst {n1.DestIP=n4.DestIP} {n12.DestIP=n2.DestIP} {n20.DestIP=n1.DestIP ^n20.DestPort=n1.DestPort} n1:DNS_HInfo {n1.DestIP=n3.DestIP} n3:Sadmind_Amslverify_Overflow {n5.DestIP=n8.SrcIP, n5.DestIP=n8.DestIP} {n2.DestIP=n6.DestIP}

n6:FTP_Put {n6.DestIP=n7.SrcIP, n6.DestIP=n7.DestIP}

{n12.DestIP=n4.DestIP}

n4:Sadmind_Ping

{n4.DestIP=n3.DestIP}

{n14.DestIP=n6.DestIP}

{n3.DestIP=n7.SrcIP, n3.DestIP=n7.DestIP}

{n1.DestIP=n2.DestIP} {n3.DestIP=n8.SrcIP, n3.DestIP=n8.DestIP} n2:HTTP_Shells {n2.DestIP=n8.SrcIP, n2.DestIP=n8.DestIP} {n2.DestIP=n7.SrcIP, n2.DestIP=n7.DestIP} {n14.DestIP=n8.SrcIP, n14.DestIP=n8.DestIP} {n14.DestIP=n7.SrcIP, n14.DestIP=n7.DestIP} n14:HTTP_Cisco_Catalyst_Exec n8:Rsh

{n8.SrcIP=n7.SrcIP, n8.SrcIP=n7.DestIP, n8.DestIP=n7.SrcIP, n8.DestIP=n7.DestIP} n7:Mstream_Zombie

{} n16:Stream_DoS

{n13.SrcIP=n7.SrcIP, n13.SrcIP=n7.DestIP} n13:HTTP_ActiveX {n15.SrcIP=n7.SrcIP, n15.SrcIP=n7.DestIP}

n15:HTTP_Java

Email_Almail_Overflow67529 Email_Almail_Overflow67304

Rsh67560 Rsh67558 Rsh67559 Rsh67553

HTTP_Shells1 FTP_Syst67243 Sadmind_Ping67343 Sadmind_Amslverify_Overflow2 Rsh8 Rsh3 Rsh5 Rsh9 Rsh10 Rsh67542 Rsh14 Rsh13 Rsh15 Rsh67540 Sadmind_Ping67286 Sadmind_Amslverify_Overflow11 Rsh67543 Rsh67545 Rsh67546 Rsh67547 Mstream_Zombie67777 Rsh67549 Rsh67550 Rsh17 Rsh16 Mstream_Zombie67563 Mstream_Zombie67767 Stream_DoS67773 Mstream_Zombie67537 Mstream_Zombie67776 FTP_Put7 Mstream_Zombie67554

Rsh67562 Sadmind_Ping67341 Sadmind_Amslverify_Overflow19 Rsh67535 Rsh67536 Rsh67538 Rsh67539 Rsh23

Figure 9. The integrated correlation graph constructed from LLDOS 1.0 inside traffic uations in our future research. vices such as IDSs and firewalls with the importance of system assets [21]. The alert clustering techniques in [13, 14] use conceptual clustering and generalization hierarchy to aggregate alerts into clusters. An interesting approach was proposed recently to apply statistical tests to identify causal relationships among aggregated alerts [22]. Alert correlation may also be performed by matching attack scenarios specified by attack languages. Examples of such languages include STATL [10], LAMBDA [6], JIGSAW [26] and Chronicles [16]. We consider these techniques as complementary to ours. Our approach is also related to techniques for static vulnerability analysis (e.g., [1, 12, 23, 24]). In particular, the methods in [1, 24] also use a model of exploits (possible attacks) in terms of their pre-conditions (prerequisites) and post-conditions (consequences) to construct possible sequences of attacks. However, our method aims to construct high-level attack scenarios from low-level intrusion alerts and reason about attacks possibly missed by the IDSs, while the vulnerability analysis techniques are in-

5. Related Work
Our work in this paper is closely related to the recent results in intrusion alert correlation. In particular, our techniques integrate the causal correlation methods in [5, 19] and the clustering correlation methods in [4, 7, 25, 27]. In addition to correlating intrusion alerts, our techniques allow to further hypothesize and reason about attacks possibly missed by the IDSs, and thus can potentially exceed the limitation of IDSs. There are other alert correlation techniques. The Tivoli approach correlates alerts based on the observation that some alerts usually occur in sequence [9]. M2D2 correlates alerts by fusing information from multiple sources besides intrusion alerts, such as the characteristics of the monitored systems and the vulnerability information [17], thus having a potential to result in better results than those simply looking at intrusion alerts. The mission-impactbased approach correlates alerts raised by INFOSEC de-

Rsh66331 Rsh66332 Rsh66333 Rsh66335 Sadmind_Ping66048 Sadmind_Amslverify_Overflow4 Rsh66336 Rsh66338
Sadmind_Ping66115 Sadmind_Amslverify_Overflow5 Rsh66352 Rsh66353 Rsh66348 Rsh66350

Rsh66341 Rsh66351

(a) Integrated Correlation Graph ICGa

(b) Integrated Correlation Graph ICGb

Sadmind_Ping66111 FTP_Syst66006 HTTP_Shells2

Sadmind_Amslverify_Overflow6 Email_Almail_Overflow66050

Rsh66345 Rsh66346 Rsh66347

Email_Almail_Overflow66320 Rsh66355

(c) Integrated Correlation Graph ICGc

Figure 10. Experimental results using the DMZ data set in LLDOS 1.0 tended to understand possible ways of combining different attacks. In our method, the investigation of the actual alerts and raw audit data presents more opportunities that cannot be provided by static vulnerability analysis. Thus, we believe that our techniques are more suitable than static vulnerability analysis when real intrusion data is available. known attacks used together with unknown attacks to identify those unknown ones. These techniques will fail if all attacks involved in a sequence attacks are unknown. Moreover, the effectiveness of these techniques for different mixtures of known and unknown attacks still requires further investigation. This paper is a starting point for improving intrusion detection through alert correlation. In our future research, we plan to continue our investigation in this direction. In particular, we will develop additional techniques to validate and reason about hypothesized attacks and perform a more thorough, quantitative evaluation of the proposed techniques.

6. Conclusion and Future Work
In this paper, we presented a series of techniques to construct high-level attack scenarios even if the underlying IDSs miss critical attacks. Our approach integrates two complementary intrusion alert correlation methods: (1) correlation based on similarity between alert attributes, and (2) correlation based on prerequisites and consequences of attacks. Moreover, our approach uses the intrinsic relationships between possibly related attacks to hypothesize missed attacks. To reason about hypothesized attacks, we developed techniques to compute constraints that indirectly related attacks must satisfy and proposed to further validate hypothesized attacks through raw audit data. Finally, we presented a technique to consolidate hypothesized attacks to generate concise representations of constructed attack scenarios. Our experimental results demonstrated the potential of these techniques. The proposed techniques can provide meaningful "guesses" of attacks possibly missed by the IDSs, and thus supply good starting points as well as supporting evidences to facilitate investigation of unknown intrusions. A limitation of these techniques is that they depend on

References
[1] P. Ammann, D. Wijesekera, and S. Kaushik. Scalable, graph-based network vulnerability analysis. In Proceedings of the 9th ACM Conference on Computer and Communications Security, pages 217­224, November 2002. [2] AT & T Research Labs. Graphviz - open source graph layout and drawing software. http://www.research. att.com/sw/tools/graphviz/. [3] G. Combs. The ethereal network analyzer. http:// www.ethereal.com. [4] F. Cuppens. Managing alerts in a multi-intrusion detection environment. In Proceedings of the 17th Annual Computer Security Applications Conference, December 2001. [5] F. Cuppens and A. Miege. Alert correlation in a cooperative intrusion detection framework. In Proceedings of the 2002 IEEE Symposium on Security and Privacy, May 2002.

[6] F. Cuppens and R. Ortalo. LAMBDA: A language to model a database for detection of attacks. In Proc. of Recent Advances in Intrusion Detection (RAID 2000), pages 197­216, September 2000. [7] O. Dain and R. Cunningham. Building scenarios from a heterogeneous alert stream. In Proceedings of the 2001 IEEE Workshop on Information Assurance and Security, pages 231­235, June 2001. [8] O. Dain and R. Cunningham. Fusing a heterogeneous alert stream into scenarios. In Proceedings of the 2001 ACM Workshop on Data Mining for Security Applications, pages 1­13, Nov. 2001. [9] H. Debar and A. Wespi. Aggregation and correlation of intrusion-detection alerts. In Recent Advances in Intrusion Detection, LNCS 2212, pages 85 ­ 103, 2001. [10] S. Eckmann, G. Vigna, and R. Kemmerer. STATL: An Attack Language for State-based Intrusion Detection. Journal of Computer Security, 10(1/2):71­104, 2002. [11] Internet Security Systems. RealSecure intrusion detection system. http://www.iss.net. [12] S. Jha, O. Sheyner, and J. Wing. Two formal analyses of attack graphs. In Proceedings of the 15th Computer Security Foundation Workshop, June 2002. [13] K. Julisch. Mining alarm clusters to improve alarm handling efficiency. In Proceedings of the 17th Annual Computer Security Applications Conference (ACSAC), pages 12­21, December 2001. [14] K. Julisch and M. Dacier. Mining intrusion detection alarms for actionable knowledge. In The 8th ACM International Conference on Knowledge Discovery and Data Mining, July 2002. [15] MIT Lincoln Lab. 2000 DARPA intrusion detection scenario specific datasets. http: //www.ll.mit.edu/IST/ideval/data/2000/ 2000_data_index.html, 2000. [16] B. Morin and H. Debar. Correlation of intrusion symptoms: an application of chronicles. In Proceedings of the 6th International Conference on Recent Advances in Intrusion Detection (RAID'03), September 2003. [17] B. Morin, L. M´ e, H. Debar, and M. Ducass´ e. M2D2: A formal data model for IDS alert correlation. In Proceedings of the 5th International Symposium on Recent Advances in Intrusion Detection (RAID 2002), pages 115­ 137, 2002. [18] P. Ning and Y. Cui. Intrusion alert correlator (version 0.2). http://discovery.csc.ncsu.edu/ software/correlator/ver0.2/iac.html, 2002. [19] P. Ning, Y. Cui, and D. S. Reeves. Constructing attack scenarios through correlation of intrusion alerts. In Proceedings of the 9th ACM Conference on Computer and Communications Security, pages 245­254, Washington, D.C., November 2002. [20] P. Ning and D. Xu. Learning attack stratagies from intrusion alerts. In Proceedings of the 10th ACM Conference on

[21]

[22]

[23]

[24]

[25]

[26]

[27]

Computer and Communications Security, October 2003. To appear. P. Porras, M. Fong, and A. Valdes. A mission-impactbased approach to INFOSEC alarm correlation. In Proceedings of the 5th International Symposium on Recent Advances in Intrusion Detection (RAID 2002), pages 95­ 114, 2002. X. Qin and W. Lee. Statistical causality analysis of infosec alert data. In Proceedings of The 6th International Symposium on Recent Advances in Intrusion Detection (RAID 2003), Pittsburgh, PA, Sept. 2003. C. Ramakrishnan and R. Sekar. Model-based analysis of configuration vulnerabilities. Journal of Computer Security, 10(1/2):189­209, 2002. O. Sheyner, J. Haines, S. Jha, R. Lippmann, and J. Wing. Automated generation and analysis of attack graphs. In Proceedings of IEEE Symposium on Security and Privacy, May 2002. S. Staniford, J. Hoagland, and J. McAlerney. Practical automated detection of stealthy portscans. Journal of Computer Security, 10(1/2):105­136, 2002. S. Templeton and K. Levitt. A requires/provides model for computer attacks. In Proceedings of New Security Paradigms Workshop, pages 31 ­ 38. ACM Press, September 2000. A. Valdes and K. Skinner. Probabilistic alert correlation. In Proceedings of the 4th International Symposium on Recent Advances in Intrusion Detection (RAID 2001), pages 54­68, 2001.

A. The Hyper-alert Types
In this appendix, we give more information about the hyper-alert types used in our examples and experiments. We present the implication relationships between predicates in Table 2. Table 3 shows all hyper-alert types used in our examples, and Table 4 describes all hyper-alert types used in our experiments. In both Tables 3 and 4, the set of fact attributes for each hyper-alert type is {SrcIP, SrcPort, DestIP, DestPort}.

Table 2. Implication relationships between the predicates
Predicate ExistService(IP,Port) GainOSInfo(IP) GainOSInfo(IP) OSSolaris(IP) GainSMTPInfo(SrcIP,DestIP) GainAccess(IP) SystemCompromised(IP) ReadyForDDOSAttack(IP) Implied Predicate GainInformation(IP) GainInformation(IP) OSSolaris(IP) OSUNIX(IP) SMTPSupportTurn(SrcIP,DestIP) SystemCompromised(IP) SystemAttack(IP) ReadyForDDOSAttack

Table 3. Hyper-alert types used in the examples
Hyper-alert Type ICMP PING NMAP SCAN NMAP TCP IMAP Authen Overflow FTP Glob Expansion Rsh Mstream Zombie Prerequisite ExistHost(DestIP) ExistService(DestIP,DestPort) VulnerableAuthenticate(DestIP) ExistService(DestIP,DestPort) VulnerableFTPRequest(DestIP) GainAccess(DestIP) GainAccess(SrcIP) SystemCompromised(DestIP) SystemCompromised(SrcIP) Consequence ExistHost(DestIP) {ExistService(DestIP,DestPort)} {GainAccess(DestIP)} {GainAccess(DestIP)} {SystemCompromised(DestIP), SystemCompromised(SrcIP)} {ReadyForDDOSAttack(DestIP), ReadyForDDOSAttack(SrcIP)}

Table 4. Hyper-alert types used in our experiments
Hyper-alert Type Admind DNS HInfo Email Almail Overflow Email Debug Email Ehlo Email Turn FTP Pass FTP Put FTP Syst FTP User HTTP ActiveX HTTP Cisco Catalyst Exec HTTP Java HTTP Shells Mstream Zombie Port Scan RIPAdd RIPExpire Rsh Sadmind Amslverify Overflow Sadmind Ping SSH Detected Stream DoS TCP Urgent Data TelnetEnvAll TelnetTerminaltype TelnetXdisplay UDP Port Scan Prerequisite ExistService(DestIP,DestPort) ExistService(DestIP,DestPort) VulnerableAlMailPOP3Server(DestIP) ExistService(DestIP,DestPort) SendMailInDebugMode(DestIP) ExistService(DestIP,DestPort) SMTPSupportEhlo(DestIP) ExistService(DestIP,DestPort) SMTPSupportTurn(SrcIP,DestIP) ExistService(DestIP,DestPort) ExistService(DestIP,DestPort) GainAccess(DestIP) ExistService(DestIP,DestPort) ExistService(DestIP,DestPort) ActiveXEnabledBrowser(SrcIP) CiscoCatalyst3500XL(DestIP) JavaEnabledBrowser(SrcIP) VulnerableCGIBin(DestIP) OSUNIX(DestIP) SystemCompromised(DestIP) SystemCompromised(SrcIP) Consequence {GainOSInfo(DestIP)} {GainAccess(DestIP)} {GainAccess(DestIP)} {GainSMTPInfo(SrcIP,DestIP)} {MailLeakage(DestIP)}

{SystemCompromised(DestIP)} {GainOSInfo(DestIP)} {SystemCompromised(SrcIP)} {GainAccess(DestIP)} {SystemCompromised(SrcIP)} {GainAccess(DestIP)} {ReadyForDDOSAttack(SrcIP), ReadyForDDOSAttack(DestIP)} {ExistService(DestIP,DestPort)}

GainAccess(DestIP) GainAccess(SrcIP) VulnerableSadmind(DestIP) OSSolaris(DestIP) OSSolaris(DestIP) ReadyForDDOSAttack

{SystemCompromised(DestIP), SystemCompromised(SrcIP)} {GainAccess(DestIP)} {VulnerableSadmind(DestIP)} {DDOSAgainst(DestIP)} {SystemAttacked(DestIP)} {SystemAttacked(DestIP)} {GainTerminalType(DestIP)} {SystemAttacked(DestIP)} {ExistService(DestIP,DestPort)}

